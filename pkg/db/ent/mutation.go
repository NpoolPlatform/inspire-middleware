// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/NpoolPlatform/inspire-middleware/pkg/db/ent/achievement"
	"github.com/NpoolPlatform/inspire-middleware/pkg/db/ent/commission"
	"github.com/NpoolPlatform/inspire-middleware/pkg/db/ent/coupon"
	"github.com/NpoolPlatform/inspire-middleware/pkg/db/ent/couponallocated"
	"github.com/NpoolPlatform/inspire-middleware/pkg/db/ent/event"
	"github.com/NpoolPlatform/inspire-middleware/pkg/db/ent/invitationcode"
	"github.com/NpoolPlatform/inspire-middleware/pkg/db/ent/predicate"
	"github.com/NpoolPlatform/inspire-middleware/pkg/db/ent/pubsubmessage"
	"github.com/NpoolPlatform/inspire-middleware/pkg/db/ent/registration"
	"github.com/NpoolPlatform/inspire-middleware/pkg/db/ent/statement"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAchievement     = "Achievement"
	TypeCommission      = "Commission"
	TypeCoupon          = "Coupon"
	TypeCouponAllocated = "CouponAllocated"
	TypeEvent           = "Event"
	TypeInvitationCode  = "InvitationCode"
	TypePubsubMessage   = "PubsubMessage"
	TypeRegistration    = "Registration"
	TypeStatement       = "Statement"
)

// AchievementMutation represents an operation that mutates the Achievement nodes in the graph.
type AchievementMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	ent_id           *uuid.UUID
	app_id           *uuid.UUID
	user_id          *uuid.UUID
	good_id          *uuid.UUID
	app_good_id      *uuid.UUID
	coin_type_id     *uuid.UUID
	total_units_v1   *decimal.Decimal
	self_units_v1    *decimal.Decimal
	total_amount     *decimal.Decimal
	self_amount      *decimal.Decimal
	total_commission *decimal.Decimal
	self_commission  *decimal.Decimal
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Achievement, error)
	predicates       []predicate.Achievement
}

var _ ent.Mutation = (*AchievementMutation)(nil)

// achievementOption allows management of the mutation configuration using functional options.
type achievementOption func(*AchievementMutation)

// newAchievementMutation creates new mutation for the Achievement entity.
func newAchievementMutation(c config, op Op, opts ...achievementOption) *AchievementMutation {
	m := &AchievementMutation{
		config:        c,
		op:            op,
		typ:           TypeAchievement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAchievementID sets the ID field of the mutation.
func withAchievementID(id uint32) achievementOption {
	return func(m *AchievementMutation) {
		var (
			err   error
			once  sync.Once
			value *Achievement
		)
		m.oldValue = func(ctx context.Context) (*Achievement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Achievement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAchievement sets the old Achievement of the mutation.
func withAchievement(node *Achievement) achievementOption {
	return func(m *AchievementMutation) {
		m.oldValue = func(context.Context) (*Achievement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AchievementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AchievementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Achievement entities.
func (m *AchievementMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AchievementMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AchievementMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Achievement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AchievementMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AchievementMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AchievementMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AchievementMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AchievementMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AchievementMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AchievementMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AchievementMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AchievementMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AchievementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AchievementMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AchievementMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AchievementMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AchievementMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AchievementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AchievementMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AchievementMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AchievementMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AchievementMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AchievementMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AchievementMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[achievement.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AchievementMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[achievement.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AchievementMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, achievement.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *AchievementMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AchievementMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AchievementMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[achievement.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AchievementMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[achievement.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AchievementMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, achievement.FieldUserID)
}

// SetGoodID sets the "good_id" field.
func (m *AchievementMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *AchievementMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *AchievementMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[achievement.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *AchievementMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[achievement.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *AchievementMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, achievement.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *AchievementMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *AchievementMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *AchievementMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[achievement.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *AchievementMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[achievement.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *AchievementMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, achievement.FieldAppGoodID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *AchievementMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *AchievementMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *AchievementMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[achievement.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *AchievementMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[achievement.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *AchievementMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, achievement.FieldCoinTypeID)
}

// SetTotalUnitsV1 sets the "total_units_v1" field.
func (m *AchievementMutation) SetTotalUnitsV1(d decimal.Decimal) {
	m.total_units_v1 = &d
}

// TotalUnitsV1 returns the value of the "total_units_v1" field in the mutation.
func (m *AchievementMutation) TotalUnitsV1() (r decimal.Decimal, exists bool) {
	v := m.total_units_v1
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalUnitsV1 returns the old "total_units_v1" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldTotalUnitsV1(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalUnitsV1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalUnitsV1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalUnitsV1: %w", err)
	}
	return oldValue.TotalUnitsV1, nil
}

// ClearTotalUnitsV1 clears the value of the "total_units_v1" field.
func (m *AchievementMutation) ClearTotalUnitsV1() {
	m.total_units_v1 = nil
	m.clearedFields[achievement.FieldTotalUnitsV1] = struct{}{}
}

// TotalUnitsV1Cleared returns if the "total_units_v1" field was cleared in this mutation.
func (m *AchievementMutation) TotalUnitsV1Cleared() bool {
	_, ok := m.clearedFields[achievement.FieldTotalUnitsV1]
	return ok
}

// ResetTotalUnitsV1 resets all changes to the "total_units_v1" field.
func (m *AchievementMutation) ResetTotalUnitsV1() {
	m.total_units_v1 = nil
	delete(m.clearedFields, achievement.FieldTotalUnitsV1)
}

// SetSelfUnitsV1 sets the "self_units_v1" field.
func (m *AchievementMutation) SetSelfUnitsV1(d decimal.Decimal) {
	m.self_units_v1 = &d
}

// SelfUnitsV1 returns the value of the "self_units_v1" field in the mutation.
func (m *AchievementMutation) SelfUnitsV1() (r decimal.Decimal, exists bool) {
	v := m.self_units_v1
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfUnitsV1 returns the old "self_units_v1" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldSelfUnitsV1(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfUnitsV1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfUnitsV1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfUnitsV1: %w", err)
	}
	return oldValue.SelfUnitsV1, nil
}

// ClearSelfUnitsV1 clears the value of the "self_units_v1" field.
func (m *AchievementMutation) ClearSelfUnitsV1() {
	m.self_units_v1 = nil
	m.clearedFields[achievement.FieldSelfUnitsV1] = struct{}{}
}

// SelfUnitsV1Cleared returns if the "self_units_v1" field was cleared in this mutation.
func (m *AchievementMutation) SelfUnitsV1Cleared() bool {
	_, ok := m.clearedFields[achievement.FieldSelfUnitsV1]
	return ok
}

// ResetSelfUnitsV1 resets all changes to the "self_units_v1" field.
func (m *AchievementMutation) ResetSelfUnitsV1() {
	m.self_units_v1 = nil
	delete(m.clearedFields, achievement.FieldSelfUnitsV1)
}

// SetTotalAmount sets the "total_amount" field.
func (m *AchievementMutation) SetTotalAmount(d decimal.Decimal) {
	m.total_amount = &d
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *AchievementMutation) TotalAmount() (r decimal.Decimal, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldTotalAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// ClearTotalAmount clears the value of the "total_amount" field.
func (m *AchievementMutation) ClearTotalAmount() {
	m.total_amount = nil
	m.clearedFields[achievement.FieldTotalAmount] = struct{}{}
}

// TotalAmountCleared returns if the "total_amount" field was cleared in this mutation.
func (m *AchievementMutation) TotalAmountCleared() bool {
	_, ok := m.clearedFields[achievement.FieldTotalAmount]
	return ok
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *AchievementMutation) ResetTotalAmount() {
	m.total_amount = nil
	delete(m.clearedFields, achievement.FieldTotalAmount)
}

// SetSelfAmount sets the "self_amount" field.
func (m *AchievementMutation) SetSelfAmount(d decimal.Decimal) {
	m.self_amount = &d
}

// SelfAmount returns the value of the "self_amount" field in the mutation.
func (m *AchievementMutation) SelfAmount() (r decimal.Decimal, exists bool) {
	v := m.self_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfAmount returns the old "self_amount" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldSelfAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfAmount: %w", err)
	}
	return oldValue.SelfAmount, nil
}

// ClearSelfAmount clears the value of the "self_amount" field.
func (m *AchievementMutation) ClearSelfAmount() {
	m.self_amount = nil
	m.clearedFields[achievement.FieldSelfAmount] = struct{}{}
}

// SelfAmountCleared returns if the "self_amount" field was cleared in this mutation.
func (m *AchievementMutation) SelfAmountCleared() bool {
	_, ok := m.clearedFields[achievement.FieldSelfAmount]
	return ok
}

// ResetSelfAmount resets all changes to the "self_amount" field.
func (m *AchievementMutation) ResetSelfAmount() {
	m.self_amount = nil
	delete(m.clearedFields, achievement.FieldSelfAmount)
}

// SetTotalCommission sets the "total_commission" field.
func (m *AchievementMutation) SetTotalCommission(d decimal.Decimal) {
	m.total_commission = &d
}

// TotalCommission returns the value of the "total_commission" field in the mutation.
func (m *AchievementMutation) TotalCommission() (r decimal.Decimal, exists bool) {
	v := m.total_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCommission returns the old "total_commission" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldTotalCommission(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCommission: %w", err)
	}
	return oldValue.TotalCommission, nil
}

// ClearTotalCommission clears the value of the "total_commission" field.
func (m *AchievementMutation) ClearTotalCommission() {
	m.total_commission = nil
	m.clearedFields[achievement.FieldTotalCommission] = struct{}{}
}

// TotalCommissionCleared returns if the "total_commission" field was cleared in this mutation.
func (m *AchievementMutation) TotalCommissionCleared() bool {
	_, ok := m.clearedFields[achievement.FieldTotalCommission]
	return ok
}

// ResetTotalCommission resets all changes to the "total_commission" field.
func (m *AchievementMutation) ResetTotalCommission() {
	m.total_commission = nil
	delete(m.clearedFields, achievement.FieldTotalCommission)
}

// SetSelfCommission sets the "self_commission" field.
func (m *AchievementMutation) SetSelfCommission(d decimal.Decimal) {
	m.self_commission = &d
}

// SelfCommission returns the value of the "self_commission" field in the mutation.
func (m *AchievementMutation) SelfCommission() (r decimal.Decimal, exists bool) {
	v := m.self_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfCommission returns the old "self_commission" field's value of the Achievement entity.
// If the Achievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AchievementMutation) OldSelfCommission(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfCommission: %w", err)
	}
	return oldValue.SelfCommission, nil
}

// ClearSelfCommission clears the value of the "self_commission" field.
func (m *AchievementMutation) ClearSelfCommission() {
	m.self_commission = nil
	m.clearedFields[achievement.FieldSelfCommission] = struct{}{}
}

// SelfCommissionCleared returns if the "self_commission" field was cleared in this mutation.
func (m *AchievementMutation) SelfCommissionCleared() bool {
	_, ok := m.clearedFields[achievement.FieldSelfCommission]
	return ok
}

// ResetSelfCommission resets all changes to the "self_commission" field.
func (m *AchievementMutation) ResetSelfCommission() {
	m.self_commission = nil
	delete(m.clearedFields, achievement.FieldSelfCommission)
}

// Where appends a list predicates to the AchievementMutation builder.
func (m *AchievementMutation) Where(ps ...predicate.Achievement) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AchievementMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Achievement).
func (m *AchievementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AchievementMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, achievement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, achievement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, achievement.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, achievement.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, achievement.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, achievement.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, achievement.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, achievement.FieldAppGoodID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, achievement.FieldCoinTypeID)
	}
	if m.total_units_v1 != nil {
		fields = append(fields, achievement.FieldTotalUnitsV1)
	}
	if m.self_units_v1 != nil {
		fields = append(fields, achievement.FieldSelfUnitsV1)
	}
	if m.total_amount != nil {
		fields = append(fields, achievement.FieldTotalAmount)
	}
	if m.self_amount != nil {
		fields = append(fields, achievement.FieldSelfAmount)
	}
	if m.total_commission != nil {
		fields = append(fields, achievement.FieldTotalCommission)
	}
	if m.self_commission != nil {
		fields = append(fields, achievement.FieldSelfCommission)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AchievementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case achievement.FieldCreatedAt:
		return m.CreatedAt()
	case achievement.FieldUpdatedAt:
		return m.UpdatedAt()
	case achievement.FieldDeletedAt:
		return m.DeletedAt()
	case achievement.FieldEntID:
		return m.EntID()
	case achievement.FieldAppID:
		return m.AppID()
	case achievement.FieldUserID:
		return m.UserID()
	case achievement.FieldGoodID:
		return m.GoodID()
	case achievement.FieldAppGoodID:
		return m.AppGoodID()
	case achievement.FieldCoinTypeID:
		return m.CoinTypeID()
	case achievement.FieldTotalUnitsV1:
		return m.TotalUnitsV1()
	case achievement.FieldSelfUnitsV1:
		return m.SelfUnitsV1()
	case achievement.FieldTotalAmount:
		return m.TotalAmount()
	case achievement.FieldSelfAmount:
		return m.SelfAmount()
	case achievement.FieldTotalCommission:
		return m.TotalCommission()
	case achievement.FieldSelfCommission:
		return m.SelfCommission()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AchievementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case achievement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case achievement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case achievement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case achievement.FieldEntID:
		return m.OldEntID(ctx)
	case achievement.FieldAppID:
		return m.OldAppID(ctx)
	case achievement.FieldUserID:
		return m.OldUserID(ctx)
	case achievement.FieldGoodID:
		return m.OldGoodID(ctx)
	case achievement.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case achievement.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case achievement.FieldTotalUnitsV1:
		return m.OldTotalUnitsV1(ctx)
	case achievement.FieldSelfUnitsV1:
		return m.OldSelfUnitsV1(ctx)
	case achievement.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case achievement.FieldSelfAmount:
		return m.OldSelfAmount(ctx)
	case achievement.FieldTotalCommission:
		return m.OldTotalCommission(ctx)
	case achievement.FieldSelfCommission:
		return m.OldSelfCommission(ctx)
	}
	return nil, fmt.Errorf("unknown Achievement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AchievementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case achievement.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case achievement.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case achievement.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case achievement.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case achievement.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case achievement.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case achievement.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case achievement.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case achievement.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case achievement.FieldTotalUnitsV1:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalUnitsV1(v)
		return nil
	case achievement.FieldSelfUnitsV1:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfUnitsV1(v)
		return nil
	case achievement.FieldTotalAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case achievement.FieldSelfAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfAmount(v)
		return nil
	case achievement.FieldTotalCommission:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCommission(v)
		return nil
	case achievement.FieldSelfCommission:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfCommission(v)
		return nil
	}
	return fmt.Errorf("unknown Achievement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AchievementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, achievement.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, achievement.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, achievement.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AchievementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case achievement.FieldCreatedAt:
		return m.AddedCreatedAt()
	case achievement.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case achievement.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AchievementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case achievement.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case achievement.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case achievement.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Achievement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AchievementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(achievement.FieldAppID) {
		fields = append(fields, achievement.FieldAppID)
	}
	if m.FieldCleared(achievement.FieldUserID) {
		fields = append(fields, achievement.FieldUserID)
	}
	if m.FieldCleared(achievement.FieldGoodID) {
		fields = append(fields, achievement.FieldGoodID)
	}
	if m.FieldCleared(achievement.FieldAppGoodID) {
		fields = append(fields, achievement.FieldAppGoodID)
	}
	if m.FieldCleared(achievement.FieldCoinTypeID) {
		fields = append(fields, achievement.FieldCoinTypeID)
	}
	if m.FieldCleared(achievement.FieldTotalUnitsV1) {
		fields = append(fields, achievement.FieldTotalUnitsV1)
	}
	if m.FieldCleared(achievement.FieldSelfUnitsV1) {
		fields = append(fields, achievement.FieldSelfUnitsV1)
	}
	if m.FieldCleared(achievement.FieldTotalAmount) {
		fields = append(fields, achievement.FieldTotalAmount)
	}
	if m.FieldCleared(achievement.FieldSelfAmount) {
		fields = append(fields, achievement.FieldSelfAmount)
	}
	if m.FieldCleared(achievement.FieldTotalCommission) {
		fields = append(fields, achievement.FieldTotalCommission)
	}
	if m.FieldCleared(achievement.FieldSelfCommission) {
		fields = append(fields, achievement.FieldSelfCommission)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AchievementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AchievementMutation) ClearField(name string) error {
	switch name {
	case achievement.FieldAppID:
		m.ClearAppID()
		return nil
	case achievement.FieldUserID:
		m.ClearUserID()
		return nil
	case achievement.FieldGoodID:
		m.ClearGoodID()
		return nil
	case achievement.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case achievement.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case achievement.FieldTotalUnitsV1:
		m.ClearTotalUnitsV1()
		return nil
	case achievement.FieldSelfUnitsV1:
		m.ClearSelfUnitsV1()
		return nil
	case achievement.FieldTotalAmount:
		m.ClearTotalAmount()
		return nil
	case achievement.FieldSelfAmount:
		m.ClearSelfAmount()
		return nil
	case achievement.FieldTotalCommission:
		m.ClearTotalCommission()
		return nil
	case achievement.FieldSelfCommission:
		m.ClearSelfCommission()
		return nil
	}
	return fmt.Errorf("unknown Achievement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AchievementMutation) ResetField(name string) error {
	switch name {
	case achievement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case achievement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case achievement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case achievement.FieldEntID:
		m.ResetEntID()
		return nil
	case achievement.FieldAppID:
		m.ResetAppID()
		return nil
	case achievement.FieldUserID:
		m.ResetUserID()
		return nil
	case achievement.FieldGoodID:
		m.ResetGoodID()
		return nil
	case achievement.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case achievement.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case achievement.FieldTotalUnitsV1:
		m.ResetTotalUnitsV1()
		return nil
	case achievement.FieldSelfUnitsV1:
		m.ResetSelfUnitsV1()
		return nil
	case achievement.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case achievement.FieldSelfAmount:
		m.ResetSelfAmount()
		return nil
	case achievement.FieldTotalCommission:
		m.ResetTotalCommission()
		return nil
	case achievement.FieldSelfCommission:
		m.ResetSelfCommission()
		return nil
	}
	return fmt.Errorf("unknown Achievement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AchievementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AchievementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AchievementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AchievementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AchievementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AchievementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AchievementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Achievement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AchievementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Achievement edge %s", name)
}

// CommissionMutation represents an operation that mutates the Commission nodes in the graph.
type CommissionMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint32
	created_at         *uint32
	addcreated_at      *int32
	updated_at         *uint32
	addupdated_at      *int32
	deleted_at         *uint32
	adddeleted_at      *int32
	ent_id             *uuid.UUID
	app_id             *uuid.UUID
	user_id            *uuid.UUID
	good_id            *uuid.UUID
	app_good_id        *uuid.UUID
	amount_or_percent  *decimal.Decimal
	start_at           *uint32
	addstart_at        *int32
	end_at             *uint32
	addend_at          *int32
	settle_type        *string
	settle_mode        *string
	settle_interval    *string
	settle_amount_type *string
	threshold          *decimal.Decimal
	order_limit        *uint32
	addorder_limit     *int32
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Commission, error)
	predicates         []predicate.Commission
}

var _ ent.Mutation = (*CommissionMutation)(nil)

// commissionOption allows management of the mutation configuration using functional options.
type commissionOption func(*CommissionMutation)

// newCommissionMutation creates new mutation for the Commission entity.
func newCommissionMutation(c config, op Op, opts ...commissionOption) *CommissionMutation {
	m := &CommissionMutation{
		config:        c,
		op:            op,
		typ:           TypeCommission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommissionID sets the ID field of the mutation.
func withCommissionID(id uint32) commissionOption {
	return func(m *CommissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Commission
		)
		m.oldValue = func(ctx context.Context) (*Commission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Commission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommission sets the old Commission of the mutation.
func withCommission(node *Commission) commissionOption {
	return func(m *CommissionMutation) {
		m.oldValue = func(context.Context) (*Commission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Commission entities.
func (m *CommissionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommissionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommissionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Commission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommissionMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommissionMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CommissionMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CommissionMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommissionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommissionMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommissionMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CommissionMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CommissionMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommissionMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommissionMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CommissionMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CommissionMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *CommissionMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *CommissionMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *CommissionMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *CommissionMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CommissionMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *CommissionMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[commission.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *CommissionMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[commission.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CommissionMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, commission.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *CommissionMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommissionMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CommissionMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[commission.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CommissionMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[commission.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommissionMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, commission.FieldUserID)
}

// SetGoodID sets the "good_id" field.
func (m *CommissionMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *CommissionMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *CommissionMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[commission.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *CommissionMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[commission.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *CommissionMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, commission.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *CommissionMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *CommissionMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *CommissionMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[commission.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *CommissionMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[commission.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *CommissionMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, commission.FieldAppGoodID)
}

// SetAmountOrPercent sets the "amount_or_percent" field.
func (m *CommissionMutation) SetAmountOrPercent(d decimal.Decimal) {
	m.amount_or_percent = &d
}

// AmountOrPercent returns the value of the "amount_or_percent" field in the mutation.
func (m *CommissionMutation) AmountOrPercent() (r decimal.Decimal, exists bool) {
	v := m.amount_or_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountOrPercent returns the old "amount_or_percent" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldAmountOrPercent(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountOrPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountOrPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountOrPercent: %w", err)
	}
	return oldValue.AmountOrPercent, nil
}

// ClearAmountOrPercent clears the value of the "amount_or_percent" field.
func (m *CommissionMutation) ClearAmountOrPercent() {
	m.amount_or_percent = nil
	m.clearedFields[commission.FieldAmountOrPercent] = struct{}{}
}

// AmountOrPercentCleared returns if the "amount_or_percent" field was cleared in this mutation.
func (m *CommissionMutation) AmountOrPercentCleared() bool {
	_, ok := m.clearedFields[commission.FieldAmountOrPercent]
	return ok
}

// ResetAmountOrPercent resets all changes to the "amount_or_percent" field.
func (m *CommissionMutation) ResetAmountOrPercent() {
	m.amount_or_percent = nil
	delete(m.clearedFields, commission.FieldAmountOrPercent)
}

// SetStartAt sets the "start_at" field.
func (m *CommissionMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *CommissionMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *CommissionMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *CommissionMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *CommissionMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[commission.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *CommissionMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[commission.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *CommissionMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, commission.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *CommissionMutation) SetEndAt(u uint32) {
	m.end_at = &u
	m.addend_at = nil
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *CommissionMutation) EndAt() (r uint32, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldEndAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// AddEndAt adds u to the "end_at" field.
func (m *CommissionMutation) AddEndAt(u int32) {
	if m.addend_at != nil {
		*m.addend_at += u
	} else {
		m.addend_at = &u
	}
}

// AddedEndAt returns the value that was added to the "end_at" field in this mutation.
func (m *CommissionMutation) AddedEndAt() (r int32, exists bool) {
	v := m.addend_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearEndAt clears the value of the "end_at" field.
func (m *CommissionMutation) ClearEndAt() {
	m.end_at = nil
	m.addend_at = nil
	m.clearedFields[commission.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *CommissionMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[commission.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *CommissionMutation) ResetEndAt() {
	m.end_at = nil
	m.addend_at = nil
	delete(m.clearedFields, commission.FieldEndAt)
}

// SetSettleType sets the "settle_type" field.
func (m *CommissionMutation) SetSettleType(s string) {
	m.settle_type = &s
}

// SettleType returns the value of the "settle_type" field in the mutation.
func (m *CommissionMutation) SettleType() (r string, exists bool) {
	v := m.settle_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSettleType returns the old "settle_type" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldSettleType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettleType: %w", err)
	}
	return oldValue.SettleType, nil
}

// ClearSettleType clears the value of the "settle_type" field.
func (m *CommissionMutation) ClearSettleType() {
	m.settle_type = nil
	m.clearedFields[commission.FieldSettleType] = struct{}{}
}

// SettleTypeCleared returns if the "settle_type" field was cleared in this mutation.
func (m *CommissionMutation) SettleTypeCleared() bool {
	_, ok := m.clearedFields[commission.FieldSettleType]
	return ok
}

// ResetSettleType resets all changes to the "settle_type" field.
func (m *CommissionMutation) ResetSettleType() {
	m.settle_type = nil
	delete(m.clearedFields, commission.FieldSettleType)
}

// SetSettleMode sets the "settle_mode" field.
func (m *CommissionMutation) SetSettleMode(s string) {
	m.settle_mode = &s
}

// SettleMode returns the value of the "settle_mode" field in the mutation.
func (m *CommissionMutation) SettleMode() (r string, exists bool) {
	v := m.settle_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldSettleMode returns the old "settle_mode" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldSettleMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettleMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettleMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettleMode: %w", err)
	}
	return oldValue.SettleMode, nil
}

// ClearSettleMode clears the value of the "settle_mode" field.
func (m *CommissionMutation) ClearSettleMode() {
	m.settle_mode = nil
	m.clearedFields[commission.FieldSettleMode] = struct{}{}
}

// SettleModeCleared returns if the "settle_mode" field was cleared in this mutation.
func (m *CommissionMutation) SettleModeCleared() bool {
	_, ok := m.clearedFields[commission.FieldSettleMode]
	return ok
}

// ResetSettleMode resets all changes to the "settle_mode" field.
func (m *CommissionMutation) ResetSettleMode() {
	m.settle_mode = nil
	delete(m.clearedFields, commission.FieldSettleMode)
}

// SetSettleInterval sets the "settle_interval" field.
func (m *CommissionMutation) SetSettleInterval(s string) {
	m.settle_interval = &s
}

// SettleInterval returns the value of the "settle_interval" field in the mutation.
func (m *CommissionMutation) SettleInterval() (r string, exists bool) {
	v := m.settle_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldSettleInterval returns the old "settle_interval" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldSettleInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettleInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettleInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettleInterval: %w", err)
	}
	return oldValue.SettleInterval, nil
}

// ClearSettleInterval clears the value of the "settle_interval" field.
func (m *CommissionMutation) ClearSettleInterval() {
	m.settle_interval = nil
	m.clearedFields[commission.FieldSettleInterval] = struct{}{}
}

// SettleIntervalCleared returns if the "settle_interval" field was cleared in this mutation.
func (m *CommissionMutation) SettleIntervalCleared() bool {
	_, ok := m.clearedFields[commission.FieldSettleInterval]
	return ok
}

// ResetSettleInterval resets all changes to the "settle_interval" field.
func (m *CommissionMutation) ResetSettleInterval() {
	m.settle_interval = nil
	delete(m.clearedFields, commission.FieldSettleInterval)
}

// SetSettleAmountType sets the "settle_amount_type" field.
func (m *CommissionMutation) SetSettleAmountType(s string) {
	m.settle_amount_type = &s
}

// SettleAmountType returns the value of the "settle_amount_type" field in the mutation.
func (m *CommissionMutation) SettleAmountType() (r string, exists bool) {
	v := m.settle_amount_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSettleAmountType returns the old "settle_amount_type" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldSettleAmountType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettleAmountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettleAmountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettleAmountType: %w", err)
	}
	return oldValue.SettleAmountType, nil
}

// ClearSettleAmountType clears the value of the "settle_amount_type" field.
func (m *CommissionMutation) ClearSettleAmountType() {
	m.settle_amount_type = nil
	m.clearedFields[commission.FieldSettleAmountType] = struct{}{}
}

// SettleAmountTypeCleared returns if the "settle_amount_type" field was cleared in this mutation.
func (m *CommissionMutation) SettleAmountTypeCleared() bool {
	_, ok := m.clearedFields[commission.FieldSettleAmountType]
	return ok
}

// ResetSettleAmountType resets all changes to the "settle_amount_type" field.
func (m *CommissionMutation) ResetSettleAmountType() {
	m.settle_amount_type = nil
	delete(m.clearedFields, commission.FieldSettleAmountType)
}

// SetThreshold sets the "threshold" field.
func (m *CommissionMutation) SetThreshold(d decimal.Decimal) {
	m.threshold = &d
}

// Threshold returns the value of the "threshold" field in the mutation.
func (m *CommissionMutation) Threshold() (r decimal.Decimal, exists bool) {
	v := m.threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldThreshold returns the old "threshold" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldThreshold(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreshold: %w", err)
	}
	return oldValue.Threshold, nil
}

// ClearThreshold clears the value of the "threshold" field.
func (m *CommissionMutation) ClearThreshold() {
	m.threshold = nil
	m.clearedFields[commission.FieldThreshold] = struct{}{}
}

// ThresholdCleared returns if the "threshold" field was cleared in this mutation.
func (m *CommissionMutation) ThresholdCleared() bool {
	_, ok := m.clearedFields[commission.FieldThreshold]
	return ok
}

// ResetThreshold resets all changes to the "threshold" field.
func (m *CommissionMutation) ResetThreshold() {
	m.threshold = nil
	delete(m.clearedFields, commission.FieldThreshold)
}

// SetOrderLimit sets the "order_limit" field.
func (m *CommissionMutation) SetOrderLimit(u uint32) {
	m.order_limit = &u
	m.addorder_limit = nil
}

// OrderLimit returns the value of the "order_limit" field in the mutation.
func (m *CommissionMutation) OrderLimit() (r uint32, exists bool) {
	v := m.order_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderLimit returns the old "order_limit" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldOrderLimit(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderLimit: %w", err)
	}
	return oldValue.OrderLimit, nil
}

// AddOrderLimit adds u to the "order_limit" field.
func (m *CommissionMutation) AddOrderLimit(u int32) {
	if m.addorder_limit != nil {
		*m.addorder_limit += u
	} else {
		m.addorder_limit = &u
	}
}

// AddedOrderLimit returns the value that was added to the "order_limit" field in this mutation.
func (m *CommissionMutation) AddedOrderLimit() (r int32, exists bool) {
	v := m.addorder_limit
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderLimit clears the value of the "order_limit" field.
func (m *CommissionMutation) ClearOrderLimit() {
	m.order_limit = nil
	m.addorder_limit = nil
	m.clearedFields[commission.FieldOrderLimit] = struct{}{}
}

// OrderLimitCleared returns if the "order_limit" field was cleared in this mutation.
func (m *CommissionMutation) OrderLimitCleared() bool {
	_, ok := m.clearedFields[commission.FieldOrderLimit]
	return ok
}

// ResetOrderLimit resets all changes to the "order_limit" field.
func (m *CommissionMutation) ResetOrderLimit() {
	m.order_limit = nil
	m.addorder_limit = nil
	delete(m.clearedFields, commission.FieldOrderLimit)
}

// Where appends a list predicates to the CommissionMutation builder.
func (m *CommissionMutation) Where(ps ...predicate.Commission) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Commission).
func (m *CommissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommissionMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, commission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, commission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, commission.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, commission.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, commission.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, commission.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, commission.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, commission.FieldAppGoodID)
	}
	if m.amount_or_percent != nil {
		fields = append(fields, commission.FieldAmountOrPercent)
	}
	if m.start_at != nil {
		fields = append(fields, commission.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, commission.FieldEndAt)
	}
	if m.settle_type != nil {
		fields = append(fields, commission.FieldSettleType)
	}
	if m.settle_mode != nil {
		fields = append(fields, commission.FieldSettleMode)
	}
	if m.settle_interval != nil {
		fields = append(fields, commission.FieldSettleInterval)
	}
	if m.settle_amount_type != nil {
		fields = append(fields, commission.FieldSettleAmountType)
	}
	if m.threshold != nil {
		fields = append(fields, commission.FieldThreshold)
	}
	if m.order_limit != nil {
		fields = append(fields, commission.FieldOrderLimit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commission.FieldCreatedAt:
		return m.CreatedAt()
	case commission.FieldUpdatedAt:
		return m.UpdatedAt()
	case commission.FieldDeletedAt:
		return m.DeletedAt()
	case commission.FieldEntID:
		return m.EntID()
	case commission.FieldAppID:
		return m.AppID()
	case commission.FieldUserID:
		return m.UserID()
	case commission.FieldGoodID:
		return m.GoodID()
	case commission.FieldAppGoodID:
		return m.AppGoodID()
	case commission.FieldAmountOrPercent:
		return m.AmountOrPercent()
	case commission.FieldStartAt:
		return m.StartAt()
	case commission.FieldEndAt:
		return m.EndAt()
	case commission.FieldSettleType:
		return m.SettleType()
	case commission.FieldSettleMode:
		return m.SettleMode()
	case commission.FieldSettleInterval:
		return m.SettleInterval()
	case commission.FieldSettleAmountType:
		return m.SettleAmountType()
	case commission.FieldThreshold:
		return m.Threshold()
	case commission.FieldOrderLimit:
		return m.OrderLimit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case commission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case commission.FieldEntID:
		return m.OldEntID(ctx)
	case commission.FieldAppID:
		return m.OldAppID(ctx)
	case commission.FieldUserID:
		return m.OldUserID(ctx)
	case commission.FieldGoodID:
		return m.OldGoodID(ctx)
	case commission.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case commission.FieldAmountOrPercent:
		return m.OldAmountOrPercent(ctx)
	case commission.FieldStartAt:
		return m.OldStartAt(ctx)
	case commission.FieldEndAt:
		return m.OldEndAt(ctx)
	case commission.FieldSettleType:
		return m.OldSettleType(ctx)
	case commission.FieldSettleMode:
		return m.OldSettleMode(ctx)
	case commission.FieldSettleInterval:
		return m.OldSettleInterval(ctx)
	case commission.FieldSettleAmountType:
		return m.OldSettleAmountType(ctx)
	case commission.FieldThreshold:
		return m.OldThreshold(ctx)
	case commission.FieldOrderLimit:
		return m.OldOrderLimit(ctx)
	}
	return nil, fmt.Errorf("unknown Commission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commission.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commission.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case commission.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case commission.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case commission.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case commission.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case commission.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case commission.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case commission.FieldAmountOrPercent:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountOrPercent(v)
		return nil
	case commission.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case commission.FieldEndAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case commission.FieldSettleType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettleType(v)
		return nil
	case commission.FieldSettleMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettleMode(v)
		return nil
	case commission.FieldSettleInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettleInterval(v)
		return nil
	case commission.FieldSettleAmountType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettleAmountType(v)
		return nil
	case commission.FieldThreshold:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreshold(v)
		return nil
	case commission.FieldOrderLimit:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderLimit(v)
		return nil
	}
	return fmt.Errorf("unknown Commission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommissionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, commission.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, commission.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, commission.FieldDeletedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, commission.FieldStartAt)
	}
	if m.addend_at != nil {
		fields = append(fields, commission.FieldEndAt)
	}
	if m.addorder_limit != nil {
		fields = append(fields, commission.FieldOrderLimit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commission.FieldCreatedAt:
		return m.AddedCreatedAt()
	case commission.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case commission.FieldDeletedAt:
		return m.AddedDeletedAt()
	case commission.FieldStartAt:
		return m.AddedStartAt()
	case commission.FieldEndAt:
		return m.AddedEndAt()
	case commission.FieldOrderLimit:
		return m.AddedOrderLimit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commission.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case commission.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case commission.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case commission.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case commission.FieldEndAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndAt(v)
		return nil
	case commission.FieldOrderLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderLimit(v)
		return nil
	}
	return fmt.Errorf("unknown Commission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(commission.FieldAppID) {
		fields = append(fields, commission.FieldAppID)
	}
	if m.FieldCleared(commission.FieldUserID) {
		fields = append(fields, commission.FieldUserID)
	}
	if m.FieldCleared(commission.FieldGoodID) {
		fields = append(fields, commission.FieldGoodID)
	}
	if m.FieldCleared(commission.FieldAppGoodID) {
		fields = append(fields, commission.FieldAppGoodID)
	}
	if m.FieldCleared(commission.FieldAmountOrPercent) {
		fields = append(fields, commission.FieldAmountOrPercent)
	}
	if m.FieldCleared(commission.FieldStartAt) {
		fields = append(fields, commission.FieldStartAt)
	}
	if m.FieldCleared(commission.FieldEndAt) {
		fields = append(fields, commission.FieldEndAt)
	}
	if m.FieldCleared(commission.FieldSettleType) {
		fields = append(fields, commission.FieldSettleType)
	}
	if m.FieldCleared(commission.FieldSettleMode) {
		fields = append(fields, commission.FieldSettleMode)
	}
	if m.FieldCleared(commission.FieldSettleInterval) {
		fields = append(fields, commission.FieldSettleInterval)
	}
	if m.FieldCleared(commission.FieldSettleAmountType) {
		fields = append(fields, commission.FieldSettleAmountType)
	}
	if m.FieldCleared(commission.FieldThreshold) {
		fields = append(fields, commission.FieldThreshold)
	}
	if m.FieldCleared(commission.FieldOrderLimit) {
		fields = append(fields, commission.FieldOrderLimit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommissionMutation) ClearField(name string) error {
	switch name {
	case commission.FieldAppID:
		m.ClearAppID()
		return nil
	case commission.FieldUserID:
		m.ClearUserID()
		return nil
	case commission.FieldGoodID:
		m.ClearGoodID()
		return nil
	case commission.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case commission.FieldAmountOrPercent:
		m.ClearAmountOrPercent()
		return nil
	case commission.FieldStartAt:
		m.ClearStartAt()
		return nil
	case commission.FieldEndAt:
		m.ClearEndAt()
		return nil
	case commission.FieldSettleType:
		m.ClearSettleType()
		return nil
	case commission.FieldSettleMode:
		m.ClearSettleMode()
		return nil
	case commission.FieldSettleInterval:
		m.ClearSettleInterval()
		return nil
	case commission.FieldSettleAmountType:
		m.ClearSettleAmountType()
		return nil
	case commission.FieldThreshold:
		m.ClearThreshold()
		return nil
	case commission.FieldOrderLimit:
		m.ClearOrderLimit()
		return nil
	}
	return fmt.Errorf("unknown Commission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommissionMutation) ResetField(name string) error {
	switch name {
	case commission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case commission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case commission.FieldEntID:
		m.ResetEntID()
		return nil
	case commission.FieldAppID:
		m.ResetAppID()
		return nil
	case commission.FieldUserID:
		m.ResetUserID()
		return nil
	case commission.FieldGoodID:
		m.ResetGoodID()
		return nil
	case commission.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case commission.FieldAmountOrPercent:
		m.ResetAmountOrPercent()
		return nil
	case commission.FieldStartAt:
		m.ResetStartAt()
		return nil
	case commission.FieldEndAt:
		m.ResetEndAt()
		return nil
	case commission.FieldSettleType:
		m.ResetSettleType()
		return nil
	case commission.FieldSettleMode:
		m.ResetSettleMode()
		return nil
	case commission.FieldSettleInterval:
		m.ResetSettleInterval()
		return nil
	case commission.FieldSettleAmountType:
		m.ResetSettleAmountType()
		return nil
	case commission.FieldThreshold:
		m.ResetThreshold()
		return nil
	case commission.FieldOrderLimit:
		m.ResetOrderLimit()
		return nil
	}
	return fmt.Errorf("unknown Commission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommissionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommissionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommissionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Commission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommissionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Commission edge %s", name)
}

// CouponMutation represents an operation that mutates the Coupon nodes in the graph.
type CouponMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *uint32
	addcreated_at     *int32
	updated_at        *uint32
	addupdated_at     *int32
	deleted_at        *uint32
	adddeleted_at     *int32
	app_id            *uuid.UUID
	user_id           *uuid.UUID
	good_id           *uuid.UUID
	app_good_id       *uuid.UUID
	denomination      *decimal.Decimal
	circulation       *decimal.Decimal
	random            *bool
	issued_by         *uuid.UUID
	start_at          *uint32
	addstart_at       *int32
	duration_days     *uint32
	addduration_days  *int32
	message           *string
	name              *string
	allocated         *decimal.Decimal
	coupon_type       *string
	threshold         *decimal.Decimal
	coupon_constraint *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Coupon, error)
	predicates        []predicate.Coupon
}

var _ ent.Mutation = (*CouponMutation)(nil)

// couponOption allows management of the mutation configuration using functional options.
type couponOption func(*CouponMutation)

// newCouponMutation creates new mutation for the Coupon entity.
func newCouponMutation(c config, op Op, opts ...couponOption) *CouponMutation {
	m := &CouponMutation{
		config:        c,
		op:            op,
		typ:           TypeCoupon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponID sets the ID field of the mutation.
func withCouponID(id uuid.UUID) couponOption {
	return func(m *CouponMutation) {
		var (
			err   error
			once  sync.Once
			value *Coupon
		)
		m.oldValue = func(ctx context.Context) (*Coupon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Coupon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoupon sets the old Coupon of the mutation.
func withCoupon(node *Coupon) couponOption {
	return func(m *CouponMutation) {
		m.oldValue = func(context.Context) (*Coupon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Coupon entities.
func (m *CouponMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Coupon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CouponMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CouponMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CouponMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CouponMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CouponMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CouponMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CouponMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CouponMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CouponMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *CouponMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CouponMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *CouponMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[coupon.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *CouponMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[coupon.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CouponMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, coupon.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *CouponMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CouponMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CouponMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[coupon.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CouponMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[coupon.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CouponMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, coupon.FieldUserID)
}

// SetGoodID sets the "good_id" field.
func (m *CouponMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *CouponMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *CouponMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[coupon.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *CouponMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[coupon.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *CouponMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, coupon.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *CouponMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *CouponMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *CouponMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[coupon.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *CouponMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[coupon.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *CouponMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, coupon.FieldAppGoodID)
}

// SetDenomination sets the "denomination" field.
func (m *CouponMutation) SetDenomination(d decimal.Decimal) {
	m.denomination = &d
}

// Denomination returns the value of the "denomination" field in the mutation.
func (m *CouponMutation) Denomination() (r decimal.Decimal, exists bool) {
	v := m.denomination
	if v == nil {
		return
	}
	return *v, true
}

// OldDenomination returns the old "denomination" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldDenomination(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDenomination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDenomination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDenomination: %w", err)
	}
	return oldValue.Denomination, nil
}

// ClearDenomination clears the value of the "denomination" field.
func (m *CouponMutation) ClearDenomination() {
	m.denomination = nil
	m.clearedFields[coupon.FieldDenomination] = struct{}{}
}

// DenominationCleared returns if the "denomination" field was cleared in this mutation.
func (m *CouponMutation) DenominationCleared() bool {
	_, ok := m.clearedFields[coupon.FieldDenomination]
	return ok
}

// ResetDenomination resets all changes to the "denomination" field.
func (m *CouponMutation) ResetDenomination() {
	m.denomination = nil
	delete(m.clearedFields, coupon.FieldDenomination)
}

// SetCirculation sets the "circulation" field.
func (m *CouponMutation) SetCirculation(d decimal.Decimal) {
	m.circulation = &d
}

// Circulation returns the value of the "circulation" field in the mutation.
func (m *CouponMutation) Circulation() (r decimal.Decimal, exists bool) {
	v := m.circulation
	if v == nil {
		return
	}
	return *v, true
}

// OldCirculation returns the old "circulation" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCirculation(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCirculation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCirculation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCirculation: %w", err)
	}
	return oldValue.Circulation, nil
}

// ClearCirculation clears the value of the "circulation" field.
func (m *CouponMutation) ClearCirculation() {
	m.circulation = nil
	m.clearedFields[coupon.FieldCirculation] = struct{}{}
}

// CirculationCleared returns if the "circulation" field was cleared in this mutation.
func (m *CouponMutation) CirculationCleared() bool {
	_, ok := m.clearedFields[coupon.FieldCirculation]
	return ok
}

// ResetCirculation resets all changes to the "circulation" field.
func (m *CouponMutation) ResetCirculation() {
	m.circulation = nil
	delete(m.clearedFields, coupon.FieldCirculation)
}

// SetRandom sets the "random" field.
func (m *CouponMutation) SetRandom(b bool) {
	m.random = &b
}

// Random returns the value of the "random" field in the mutation.
func (m *CouponMutation) Random() (r bool, exists bool) {
	v := m.random
	if v == nil {
		return
	}
	return *v, true
}

// OldRandom returns the old "random" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldRandom(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRandom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRandom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRandom: %w", err)
	}
	return oldValue.Random, nil
}

// ClearRandom clears the value of the "random" field.
func (m *CouponMutation) ClearRandom() {
	m.random = nil
	m.clearedFields[coupon.FieldRandom] = struct{}{}
}

// RandomCleared returns if the "random" field was cleared in this mutation.
func (m *CouponMutation) RandomCleared() bool {
	_, ok := m.clearedFields[coupon.FieldRandom]
	return ok
}

// ResetRandom resets all changes to the "random" field.
func (m *CouponMutation) ResetRandom() {
	m.random = nil
	delete(m.clearedFields, coupon.FieldRandom)
}

// SetIssuedBy sets the "issued_by" field.
func (m *CouponMutation) SetIssuedBy(u uuid.UUID) {
	m.issued_by = &u
}

// IssuedBy returns the value of the "issued_by" field in the mutation.
func (m *CouponMutation) IssuedBy() (r uuid.UUID, exists bool) {
	v := m.issued_by
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuedBy returns the old "issued_by" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldIssuedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuedBy: %w", err)
	}
	return oldValue.IssuedBy, nil
}

// ResetIssuedBy resets all changes to the "issued_by" field.
func (m *CouponMutation) ResetIssuedBy() {
	m.issued_by = nil
}

// SetStartAt sets the "start_at" field.
func (m *CouponMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *CouponMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *CouponMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *CouponMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *CouponMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[coupon.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *CouponMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[coupon.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *CouponMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, coupon.FieldStartAt)
}

// SetDurationDays sets the "duration_days" field.
func (m *CouponMutation) SetDurationDays(u uint32) {
	m.duration_days = &u
	m.addduration_days = nil
}

// DurationDays returns the value of the "duration_days" field in the mutation.
func (m *CouponMutation) DurationDays() (r uint32, exists bool) {
	v := m.duration_days
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationDays returns the old "duration_days" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldDurationDays(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationDays: %w", err)
	}
	return oldValue.DurationDays, nil
}

// AddDurationDays adds u to the "duration_days" field.
func (m *CouponMutation) AddDurationDays(u int32) {
	if m.addduration_days != nil {
		*m.addduration_days += u
	} else {
		m.addduration_days = &u
	}
}

// AddedDurationDays returns the value that was added to the "duration_days" field in this mutation.
func (m *CouponMutation) AddedDurationDays() (r int32, exists bool) {
	v := m.addduration_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationDays clears the value of the "duration_days" field.
func (m *CouponMutation) ClearDurationDays() {
	m.duration_days = nil
	m.addduration_days = nil
	m.clearedFields[coupon.FieldDurationDays] = struct{}{}
}

// DurationDaysCleared returns if the "duration_days" field was cleared in this mutation.
func (m *CouponMutation) DurationDaysCleared() bool {
	_, ok := m.clearedFields[coupon.FieldDurationDays]
	return ok
}

// ResetDurationDays resets all changes to the "duration_days" field.
func (m *CouponMutation) ResetDurationDays() {
	m.duration_days = nil
	m.addduration_days = nil
	delete(m.clearedFields, coupon.FieldDurationDays)
}

// SetMessage sets the "message" field.
func (m *CouponMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CouponMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *CouponMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[coupon.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *CouponMutation) MessageCleared() bool {
	_, ok := m.clearedFields[coupon.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *CouponMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, coupon.FieldMessage)
}

// SetName sets the "name" field.
func (m *CouponMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CouponMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *CouponMutation) ClearName() {
	m.name = nil
	m.clearedFields[coupon.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *CouponMutation) NameCleared() bool {
	_, ok := m.clearedFields[coupon.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *CouponMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, coupon.FieldName)
}

// SetAllocated sets the "allocated" field.
func (m *CouponMutation) SetAllocated(d decimal.Decimal) {
	m.allocated = &d
}

// Allocated returns the value of the "allocated" field in the mutation.
func (m *CouponMutation) Allocated() (r decimal.Decimal, exists bool) {
	v := m.allocated
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocated returns the old "allocated" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldAllocated(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllocated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllocated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocated: %w", err)
	}
	return oldValue.Allocated, nil
}

// ClearAllocated clears the value of the "allocated" field.
func (m *CouponMutation) ClearAllocated() {
	m.allocated = nil
	m.clearedFields[coupon.FieldAllocated] = struct{}{}
}

// AllocatedCleared returns if the "allocated" field was cleared in this mutation.
func (m *CouponMutation) AllocatedCleared() bool {
	_, ok := m.clearedFields[coupon.FieldAllocated]
	return ok
}

// ResetAllocated resets all changes to the "allocated" field.
func (m *CouponMutation) ResetAllocated() {
	m.allocated = nil
	delete(m.clearedFields, coupon.FieldAllocated)
}

// SetCouponType sets the "coupon_type" field.
func (m *CouponMutation) SetCouponType(s string) {
	m.coupon_type = &s
}

// CouponType returns the value of the "coupon_type" field in the mutation.
func (m *CouponMutation) CouponType() (r string, exists bool) {
	v := m.coupon_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponType returns the old "coupon_type" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCouponType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponType: %w", err)
	}
	return oldValue.CouponType, nil
}

// ClearCouponType clears the value of the "coupon_type" field.
func (m *CouponMutation) ClearCouponType() {
	m.coupon_type = nil
	m.clearedFields[coupon.FieldCouponType] = struct{}{}
}

// CouponTypeCleared returns if the "coupon_type" field was cleared in this mutation.
func (m *CouponMutation) CouponTypeCleared() bool {
	_, ok := m.clearedFields[coupon.FieldCouponType]
	return ok
}

// ResetCouponType resets all changes to the "coupon_type" field.
func (m *CouponMutation) ResetCouponType() {
	m.coupon_type = nil
	delete(m.clearedFields, coupon.FieldCouponType)
}

// SetThreshold sets the "threshold" field.
func (m *CouponMutation) SetThreshold(d decimal.Decimal) {
	m.threshold = &d
}

// Threshold returns the value of the "threshold" field in the mutation.
func (m *CouponMutation) Threshold() (r decimal.Decimal, exists bool) {
	v := m.threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldThreshold returns the old "threshold" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldThreshold(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreshold: %w", err)
	}
	return oldValue.Threshold, nil
}

// ClearThreshold clears the value of the "threshold" field.
func (m *CouponMutation) ClearThreshold() {
	m.threshold = nil
	m.clearedFields[coupon.FieldThreshold] = struct{}{}
}

// ThresholdCleared returns if the "threshold" field was cleared in this mutation.
func (m *CouponMutation) ThresholdCleared() bool {
	_, ok := m.clearedFields[coupon.FieldThreshold]
	return ok
}

// ResetThreshold resets all changes to the "threshold" field.
func (m *CouponMutation) ResetThreshold() {
	m.threshold = nil
	delete(m.clearedFields, coupon.FieldThreshold)
}

// SetCouponConstraint sets the "coupon_constraint" field.
func (m *CouponMutation) SetCouponConstraint(s string) {
	m.coupon_constraint = &s
}

// CouponConstraint returns the value of the "coupon_constraint" field in the mutation.
func (m *CouponMutation) CouponConstraint() (r string, exists bool) {
	v := m.coupon_constraint
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponConstraint returns the old "coupon_constraint" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCouponConstraint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponConstraint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponConstraint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponConstraint: %w", err)
	}
	return oldValue.CouponConstraint, nil
}

// ClearCouponConstraint clears the value of the "coupon_constraint" field.
func (m *CouponMutation) ClearCouponConstraint() {
	m.coupon_constraint = nil
	m.clearedFields[coupon.FieldCouponConstraint] = struct{}{}
}

// CouponConstraintCleared returns if the "coupon_constraint" field was cleared in this mutation.
func (m *CouponMutation) CouponConstraintCleared() bool {
	_, ok := m.clearedFields[coupon.FieldCouponConstraint]
	return ok
}

// ResetCouponConstraint resets all changes to the "coupon_constraint" field.
func (m *CouponMutation) ResetCouponConstraint() {
	m.coupon_constraint = nil
	delete(m.clearedFields, coupon.FieldCouponConstraint)
}

// Where appends a list predicates to the CouponMutation builder.
func (m *CouponMutation) Where(ps ...predicate.Coupon) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CouponMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Coupon).
func (m *CouponMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, coupon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coupon.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, coupon.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, coupon.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, coupon.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, coupon.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, coupon.FieldAppGoodID)
	}
	if m.denomination != nil {
		fields = append(fields, coupon.FieldDenomination)
	}
	if m.circulation != nil {
		fields = append(fields, coupon.FieldCirculation)
	}
	if m.random != nil {
		fields = append(fields, coupon.FieldRandom)
	}
	if m.issued_by != nil {
		fields = append(fields, coupon.FieldIssuedBy)
	}
	if m.start_at != nil {
		fields = append(fields, coupon.FieldStartAt)
	}
	if m.duration_days != nil {
		fields = append(fields, coupon.FieldDurationDays)
	}
	if m.message != nil {
		fields = append(fields, coupon.FieldMessage)
	}
	if m.name != nil {
		fields = append(fields, coupon.FieldName)
	}
	if m.allocated != nil {
		fields = append(fields, coupon.FieldAllocated)
	}
	if m.coupon_type != nil {
		fields = append(fields, coupon.FieldCouponType)
	}
	if m.threshold != nil {
		fields = append(fields, coupon.FieldThreshold)
	}
	if m.coupon_constraint != nil {
		fields = append(fields, coupon.FieldCouponConstraint)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldCreatedAt:
		return m.CreatedAt()
	case coupon.FieldUpdatedAt:
		return m.UpdatedAt()
	case coupon.FieldDeletedAt:
		return m.DeletedAt()
	case coupon.FieldAppID:
		return m.AppID()
	case coupon.FieldUserID:
		return m.UserID()
	case coupon.FieldGoodID:
		return m.GoodID()
	case coupon.FieldAppGoodID:
		return m.AppGoodID()
	case coupon.FieldDenomination:
		return m.Denomination()
	case coupon.FieldCirculation:
		return m.Circulation()
	case coupon.FieldRandom:
		return m.Random()
	case coupon.FieldIssuedBy:
		return m.IssuedBy()
	case coupon.FieldStartAt:
		return m.StartAt()
	case coupon.FieldDurationDays:
		return m.DurationDays()
	case coupon.FieldMessage:
		return m.Message()
	case coupon.FieldName:
		return m.Name()
	case coupon.FieldAllocated:
		return m.Allocated()
	case coupon.FieldCouponType:
		return m.CouponType()
	case coupon.FieldThreshold:
		return m.Threshold()
	case coupon.FieldCouponConstraint:
		return m.CouponConstraint()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coupon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coupon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case coupon.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case coupon.FieldAppID:
		return m.OldAppID(ctx)
	case coupon.FieldUserID:
		return m.OldUserID(ctx)
	case coupon.FieldGoodID:
		return m.OldGoodID(ctx)
	case coupon.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case coupon.FieldDenomination:
		return m.OldDenomination(ctx)
	case coupon.FieldCirculation:
		return m.OldCirculation(ctx)
	case coupon.FieldRandom:
		return m.OldRandom(ctx)
	case coupon.FieldIssuedBy:
		return m.OldIssuedBy(ctx)
	case coupon.FieldStartAt:
		return m.OldStartAt(ctx)
	case coupon.FieldDurationDays:
		return m.OldDurationDays(ctx)
	case coupon.FieldMessage:
		return m.OldMessage(ctx)
	case coupon.FieldName:
		return m.OldName(ctx)
	case coupon.FieldAllocated:
		return m.OldAllocated(ctx)
	case coupon.FieldCouponType:
		return m.OldCouponType(ctx)
	case coupon.FieldThreshold:
		return m.OldThreshold(ctx)
	case coupon.FieldCouponConstraint:
		return m.OldCouponConstraint(ctx)
	}
	return nil, fmt.Errorf("unknown Coupon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coupon.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case coupon.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case coupon.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case coupon.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case coupon.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case coupon.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case coupon.FieldDenomination:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDenomination(v)
		return nil
	case coupon.FieldCirculation:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCirculation(v)
		return nil
	case coupon.FieldRandom:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRandom(v)
		return nil
	case coupon.FieldIssuedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuedBy(v)
		return nil
	case coupon.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case coupon.FieldDurationDays:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationDays(v)
		return nil
	case coupon.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case coupon.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case coupon.FieldAllocated:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocated(v)
		return nil
	case coupon.FieldCouponType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponType(v)
		return nil
	case coupon.FieldThreshold:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreshold(v)
		return nil
	case coupon.FieldCouponConstraint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponConstraint(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, coupon.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, coupon.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, coupon.FieldDeletedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, coupon.FieldStartAt)
	}
	if m.addduration_days != nil {
		fields = append(fields, coupon.FieldDurationDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldCreatedAt:
		return m.AddedCreatedAt()
	case coupon.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case coupon.FieldDeletedAt:
		return m.AddedDeletedAt()
	case coupon.FieldStartAt:
		return m.AddedStartAt()
	case coupon.FieldDurationDays:
		return m.AddedDurationDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case coupon.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case coupon.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case coupon.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	case coupon.FieldDurationDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationDays(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coupon.FieldAppID) {
		fields = append(fields, coupon.FieldAppID)
	}
	if m.FieldCleared(coupon.FieldUserID) {
		fields = append(fields, coupon.FieldUserID)
	}
	if m.FieldCleared(coupon.FieldGoodID) {
		fields = append(fields, coupon.FieldGoodID)
	}
	if m.FieldCleared(coupon.FieldAppGoodID) {
		fields = append(fields, coupon.FieldAppGoodID)
	}
	if m.FieldCleared(coupon.FieldDenomination) {
		fields = append(fields, coupon.FieldDenomination)
	}
	if m.FieldCleared(coupon.FieldCirculation) {
		fields = append(fields, coupon.FieldCirculation)
	}
	if m.FieldCleared(coupon.FieldRandom) {
		fields = append(fields, coupon.FieldRandom)
	}
	if m.FieldCleared(coupon.FieldStartAt) {
		fields = append(fields, coupon.FieldStartAt)
	}
	if m.FieldCleared(coupon.FieldDurationDays) {
		fields = append(fields, coupon.FieldDurationDays)
	}
	if m.FieldCleared(coupon.FieldMessage) {
		fields = append(fields, coupon.FieldMessage)
	}
	if m.FieldCleared(coupon.FieldName) {
		fields = append(fields, coupon.FieldName)
	}
	if m.FieldCleared(coupon.FieldAllocated) {
		fields = append(fields, coupon.FieldAllocated)
	}
	if m.FieldCleared(coupon.FieldCouponType) {
		fields = append(fields, coupon.FieldCouponType)
	}
	if m.FieldCleared(coupon.FieldThreshold) {
		fields = append(fields, coupon.FieldThreshold)
	}
	if m.FieldCleared(coupon.FieldCouponConstraint) {
		fields = append(fields, coupon.FieldCouponConstraint)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponMutation) ClearField(name string) error {
	switch name {
	case coupon.FieldAppID:
		m.ClearAppID()
		return nil
	case coupon.FieldUserID:
		m.ClearUserID()
		return nil
	case coupon.FieldGoodID:
		m.ClearGoodID()
		return nil
	case coupon.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case coupon.FieldDenomination:
		m.ClearDenomination()
		return nil
	case coupon.FieldCirculation:
		m.ClearCirculation()
		return nil
	case coupon.FieldRandom:
		m.ClearRandom()
		return nil
	case coupon.FieldStartAt:
		m.ClearStartAt()
		return nil
	case coupon.FieldDurationDays:
		m.ClearDurationDays()
		return nil
	case coupon.FieldMessage:
		m.ClearMessage()
		return nil
	case coupon.FieldName:
		m.ClearName()
		return nil
	case coupon.FieldAllocated:
		m.ClearAllocated()
		return nil
	case coupon.FieldCouponType:
		m.ClearCouponType()
		return nil
	case coupon.FieldThreshold:
		m.ClearThreshold()
		return nil
	case coupon.FieldCouponConstraint:
		m.ClearCouponConstraint()
		return nil
	}
	return fmt.Errorf("unknown Coupon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponMutation) ResetField(name string) error {
	switch name {
	case coupon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coupon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case coupon.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case coupon.FieldAppID:
		m.ResetAppID()
		return nil
	case coupon.FieldUserID:
		m.ResetUserID()
		return nil
	case coupon.FieldGoodID:
		m.ResetGoodID()
		return nil
	case coupon.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case coupon.FieldDenomination:
		m.ResetDenomination()
		return nil
	case coupon.FieldCirculation:
		m.ResetCirculation()
		return nil
	case coupon.FieldRandom:
		m.ResetRandom()
		return nil
	case coupon.FieldIssuedBy:
		m.ResetIssuedBy()
		return nil
	case coupon.FieldStartAt:
		m.ResetStartAt()
		return nil
	case coupon.FieldDurationDays:
		m.ResetDurationDays()
		return nil
	case coupon.FieldMessage:
		m.ResetMessage()
		return nil
	case coupon.FieldName:
		m.ResetName()
		return nil
	case coupon.FieldAllocated:
		m.ResetAllocated()
		return nil
	case coupon.FieldCouponType:
		m.ResetCouponType()
		return nil
	case coupon.FieldThreshold:
		m.ResetThreshold()
		return nil
	case coupon.FieldCouponConstraint:
		m.ResetCouponConstraint()
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Coupon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Coupon edge %s", name)
}

// CouponAllocatedMutation represents an operation that mutates the CouponAllocated nodes in the graph.
type CouponAllocatedMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	app_id           *uuid.UUID
	user_id          *uuid.UUID
	coupon_id        *uuid.UUID
	denomination     *decimal.Decimal
	used             *bool
	used_at          *uint32
	addused_at       *int32
	used_by_order_id *uuid.UUID
	start_at         *uint32
	addstart_at      *int32
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*CouponAllocated, error)
	predicates       []predicate.CouponAllocated
}

var _ ent.Mutation = (*CouponAllocatedMutation)(nil)

// couponallocatedOption allows management of the mutation configuration using functional options.
type couponallocatedOption func(*CouponAllocatedMutation)

// newCouponAllocatedMutation creates new mutation for the CouponAllocated entity.
func newCouponAllocatedMutation(c config, op Op, opts ...couponallocatedOption) *CouponAllocatedMutation {
	m := &CouponAllocatedMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponAllocated,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponAllocatedID sets the ID field of the mutation.
func withCouponAllocatedID(id uuid.UUID) couponallocatedOption {
	return func(m *CouponAllocatedMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponAllocated
		)
		m.oldValue = func(ctx context.Context) (*CouponAllocated, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponAllocated.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponAllocated sets the old CouponAllocated of the mutation.
func withCouponAllocated(node *CouponAllocated) couponallocatedOption {
	return func(m *CouponAllocatedMutation) {
		m.oldValue = func(context.Context) (*CouponAllocated, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponAllocatedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponAllocatedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CouponAllocated entities.
func (m *CouponAllocatedMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponAllocatedMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponAllocatedMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CouponAllocated.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponAllocatedMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponAllocatedMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CouponAllocatedMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CouponAllocatedMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponAllocatedMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponAllocatedMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponAllocatedMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CouponAllocatedMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CouponAllocatedMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponAllocatedMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CouponAllocatedMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CouponAllocatedMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CouponAllocatedMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CouponAllocatedMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CouponAllocatedMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *CouponAllocatedMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *CouponAllocatedMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *CouponAllocatedMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *CouponAllocatedMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CouponAllocatedMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CouponAllocatedMutation) ResetUserID() {
	m.user_id = nil
}

// SetCouponID sets the "coupon_id" field.
func (m *CouponAllocatedMutation) SetCouponID(u uuid.UUID) {
	m.coupon_id = &u
}

// CouponID returns the value of the "coupon_id" field in the mutation.
func (m *CouponAllocatedMutation) CouponID() (r uuid.UUID, exists bool) {
	v := m.coupon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponID returns the old "coupon_id" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldCouponID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponID: %w", err)
	}
	return oldValue.CouponID, nil
}

// ResetCouponID resets all changes to the "coupon_id" field.
func (m *CouponAllocatedMutation) ResetCouponID() {
	m.coupon_id = nil
}

// SetDenomination sets the "denomination" field.
func (m *CouponAllocatedMutation) SetDenomination(d decimal.Decimal) {
	m.denomination = &d
}

// Denomination returns the value of the "denomination" field in the mutation.
func (m *CouponAllocatedMutation) Denomination() (r decimal.Decimal, exists bool) {
	v := m.denomination
	if v == nil {
		return
	}
	return *v, true
}

// OldDenomination returns the old "denomination" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldDenomination(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDenomination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDenomination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDenomination: %w", err)
	}
	return oldValue.Denomination, nil
}

// ClearDenomination clears the value of the "denomination" field.
func (m *CouponAllocatedMutation) ClearDenomination() {
	m.denomination = nil
	m.clearedFields[couponallocated.FieldDenomination] = struct{}{}
}

// DenominationCleared returns if the "denomination" field was cleared in this mutation.
func (m *CouponAllocatedMutation) DenominationCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldDenomination]
	return ok
}

// ResetDenomination resets all changes to the "denomination" field.
func (m *CouponAllocatedMutation) ResetDenomination() {
	m.denomination = nil
	delete(m.clearedFields, couponallocated.FieldDenomination)
}

// SetUsed sets the "used" field.
func (m *CouponAllocatedMutation) SetUsed(b bool) {
	m.used = &b
}

// Used returns the value of the "used" field in the mutation.
func (m *CouponAllocatedMutation) Used() (r bool, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// ClearUsed clears the value of the "used" field.
func (m *CouponAllocatedMutation) ClearUsed() {
	m.used = nil
	m.clearedFields[couponallocated.FieldUsed] = struct{}{}
}

// UsedCleared returns if the "used" field was cleared in this mutation.
func (m *CouponAllocatedMutation) UsedCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldUsed]
	return ok
}

// ResetUsed resets all changes to the "used" field.
func (m *CouponAllocatedMutation) ResetUsed() {
	m.used = nil
	delete(m.clearedFields, couponallocated.FieldUsed)
}

// SetUsedAt sets the "used_at" field.
func (m *CouponAllocatedMutation) SetUsedAt(u uint32) {
	m.used_at = &u
	m.addused_at = nil
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *CouponAllocatedMutation) UsedAt() (r uint32, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUsedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// AddUsedAt adds u to the "used_at" field.
func (m *CouponAllocatedMutation) AddUsedAt(u int32) {
	if m.addused_at != nil {
		*m.addused_at += u
	} else {
		m.addused_at = &u
	}
}

// AddedUsedAt returns the value that was added to the "used_at" field in this mutation.
func (m *CouponAllocatedMutation) AddedUsedAt() (r int32, exists bool) {
	v := m.addused_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *CouponAllocatedMutation) ClearUsedAt() {
	m.used_at = nil
	m.addused_at = nil
	m.clearedFields[couponallocated.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *CouponAllocatedMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *CouponAllocatedMutation) ResetUsedAt() {
	m.used_at = nil
	m.addused_at = nil
	delete(m.clearedFields, couponallocated.FieldUsedAt)
}

// SetUsedByOrderID sets the "used_by_order_id" field.
func (m *CouponAllocatedMutation) SetUsedByOrderID(u uuid.UUID) {
	m.used_by_order_id = &u
}

// UsedByOrderID returns the value of the "used_by_order_id" field in the mutation.
func (m *CouponAllocatedMutation) UsedByOrderID() (r uuid.UUID, exists bool) {
	v := m.used_by_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedByOrderID returns the old "used_by_order_id" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldUsedByOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedByOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedByOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedByOrderID: %w", err)
	}
	return oldValue.UsedByOrderID, nil
}

// ClearUsedByOrderID clears the value of the "used_by_order_id" field.
func (m *CouponAllocatedMutation) ClearUsedByOrderID() {
	m.used_by_order_id = nil
	m.clearedFields[couponallocated.FieldUsedByOrderID] = struct{}{}
}

// UsedByOrderIDCleared returns if the "used_by_order_id" field was cleared in this mutation.
func (m *CouponAllocatedMutation) UsedByOrderIDCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldUsedByOrderID]
	return ok
}

// ResetUsedByOrderID resets all changes to the "used_by_order_id" field.
func (m *CouponAllocatedMutation) ResetUsedByOrderID() {
	m.used_by_order_id = nil
	delete(m.clearedFields, couponallocated.FieldUsedByOrderID)
}

// SetStartAt sets the "start_at" field.
func (m *CouponAllocatedMutation) SetStartAt(u uint32) {
	m.start_at = &u
	m.addstart_at = nil
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *CouponAllocatedMutation) StartAt() (r uint32, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the CouponAllocated entity.
// If the CouponAllocated object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAllocatedMutation) OldStartAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// AddStartAt adds u to the "start_at" field.
func (m *CouponAllocatedMutation) AddStartAt(u int32) {
	if m.addstart_at != nil {
		*m.addstart_at += u
	} else {
		m.addstart_at = &u
	}
}

// AddedStartAt returns the value that was added to the "start_at" field in this mutation.
func (m *CouponAllocatedMutation) AddedStartAt() (r int32, exists bool) {
	v := m.addstart_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartAt clears the value of the "start_at" field.
func (m *CouponAllocatedMutation) ClearStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	m.clearedFields[couponallocated.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *CouponAllocatedMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[couponallocated.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *CouponAllocatedMutation) ResetStartAt() {
	m.start_at = nil
	m.addstart_at = nil
	delete(m.clearedFields, couponallocated.FieldStartAt)
}

// Where appends a list predicates to the CouponAllocatedMutation builder.
func (m *CouponAllocatedMutation) Where(ps ...predicate.CouponAllocated) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CouponAllocatedMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CouponAllocated).
func (m *CouponAllocatedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponAllocatedMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, couponallocated.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, couponallocated.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, couponallocated.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, couponallocated.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, couponallocated.FieldUserID)
	}
	if m.coupon_id != nil {
		fields = append(fields, couponallocated.FieldCouponID)
	}
	if m.denomination != nil {
		fields = append(fields, couponallocated.FieldDenomination)
	}
	if m.used != nil {
		fields = append(fields, couponallocated.FieldUsed)
	}
	if m.used_at != nil {
		fields = append(fields, couponallocated.FieldUsedAt)
	}
	if m.used_by_order_id != nil {
		fields = append(fields, couponallocated.FieldUsedByOrderID)
	}
	if m.start_at != nil {
		fields = append(fields, couponallocated.FieldStartAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponAllocatedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case couponallocated.FieldCreatedAt:
		return m.CreatedAt()
	case couponallocated.FieldUpdatedAt:
		return m.UpdatedAt()
	case couponallocated.FieldDeletedAt:
		return m.DeletedAt()
	case couponallocated.FieldAppID:
		return m.AppID()
	case couponallocated.FieldUserID:
		return m.UserID()
	case couponallocated.FieldCouponID:
		return m.CouponID()
	case couponallocated.FieldDenomination:
		return m.Denomination()
	case couponallocated.FieldUsed:
		return m.Used()
	case couponallocated.FieldUsedAt:
		return m.UsedAt()
	case couponallocated.FieldUsedByOrderID:
		return m.UsedByOrderID()
	case couponallocated.FieldStartAt:
		return m.StartAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponAllocatedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case couponallocated.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case couponallocated.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case couponallocated.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case couponallocated.FieldAppID:
		return m.OldAppID(ctx)
	case couponallocated.FieldUserID:
		return m.OldUserID(ctx)
	case couponallocated.FieldCouponID:
		return m.OldCouponID(ctx)
	case couponallocated.FieldDenomination:
		return m.OldDenomination(ctx)
	case couponallocated.FieldUsed:
		return m.OldUsed(ctx)
	case couponallocated.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case couponallocated.FieldUsedByOrderID:
		return m.OldUsedByOrderID(ctx)
	case couponallocated.FieldStartAt:
		return m.OldStartAt(ctx)
	}
	return nil, fmt.Errorf("unknown CouponAllocated field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponAllocatedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case couponallocated.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case couponallocated.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case couponallocated.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case couponallocated.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case couponallocated.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case couponallocated.FieldCouponID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponID(v)
		return nil
	case couponallocated.FieldDenomination:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDenomination(v)
		return nil
	case couponallocated.FieldUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	case couponallocated.FieldUsedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case couponallocated.FieldUsedByOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedByOrderID(v)
		return nil
	case couponallocated.FieldStartAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	}
	return fmt.Errorf("unknown CouponAllocated field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponAllocatedMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, couponallocated.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, couponallocated.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, couponallocated.FieldDeletedAt)
	}
	if m.addused_at != nil {
		fields = append(fields, couponallocated.FieldUsedAt)
	}
	if m.addstart_at != nil {
		fields = append(fields, couponallocated.FieldStartAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponAllocatedMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case couponallocated.FieldCreatedAt:
		return m.AddedCreatedAt()
	case couponallocated.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case couponallocated.FieldDeletedAt:
		return m.AddedDeletedAt()
	case couponallocated.FieldUsedAt:
		return m.AddedUsedAt()
	case couponallocated.FieldStartAt:
		return m.AddedStartAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponAllocatedMutation) AddField(name string, value ent.Value) error {
	switch name {
	case couponallocated.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case couponallocated.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case couponallocated.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case couponallocated.FieldUsedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedAt(v)
		return nil
	case couponallocated.FieldStartAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAt(v)
		return nil
	}
	return fmt.Errorf("unknown CouponAllocated numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponAllocatedMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(couponallocated.FieldDenomination) {
		fields = append(fields, couponallocated.FieldDenomination)
	}
	if m.FieldCleared(couponallocated.FieldUsed) {
		fields = append(fields, couponallocated.FieldUsed)
	}
	if m.FieldCleared(couponallocated.FieldUsedAt) {
		fields = append(fields, couponallocated.FieldUsedAt)
	}
	if m.FieldCleared(couponallocated.FieldUsedByOrderID) {
		fields = append(fields, couponallocated.FieldUsedByOrderID)
	}
	if m.FieldCleared(couponallocated.FieldStartAt) {
		fields = append(fields, couponallocated.FieldStartAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponAllocatedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponAllocatedMutation) ClearField(name string) error {
	switch name {
	case couponallocated.FieldDenomination:
		m.ClearDenomination()
		return nil
	case couponallocated.FieldUsed:
		m.ClearUsed()
		return nil
	case couponallocated.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	case couponallocated.FieldUsedByOrderID:
		m.ClearUsedByOrderID()
		return nil
	case couponallocated.FieldStartAt:
		m.ClearStartAt()
		return nil
	}
	return fmt.Errorf("unknown CouponAllocated nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponAllocatedMutation) ResetField(name string) error {
	switch name {
	case couponallocated.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case couponallocated.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case couponallocated.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case couponallocated.FieldAppID:
		m.ResetAppID()
		return nil
	case couponallocated.FieldUserID:
		m.ResetUserID()
		return nil
	case couponallocated.FieldCouponID:
		m.ResetCouponID()
		return nil
	case couponallocated.FieldDenomination:
		m.ResetDenomination()
		return nil
	case couponallocated.FieldUsed:
		m.ResetUsed()
		return nil
	case couponallocated.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case couponallocated.FieldUsedByOrderID:
		m.ResetUsedByOrderID()
		return nil
	case couponallocated.FieldStartAt:
		m.ResetStartAt()
		return nil
	}
	return fmt.Errorf("unknown CouponAllocated field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponAllocatedMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponAllocatedMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponAllocatedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponAllocatedMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponAllocatedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponAllocatedMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponAllocatedMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CouponAllocated unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponAllocatedMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CouponAllocated edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint32
	created_at         *uint32
	addcreated_at      *int32
	updated_at         *uint32
	addupdated_at      *int32
	deleted_at         *uint32
	adddeleted_at      *int32
	ent_id             *uuid.UUID
	app_id             *uuid.UUID
	event_type         *string
	coupon_ids         *[]uuid.UUID
	credits            *decimal.Decimal
	credits_per_usd    *decimal.Decimal
	max_consecutive    *uint32
	addmax_consecutive *int32
	good_id            *uuid.UUID
	app_good_id        *uuid.UUID
	inviter_layers     *uint32
	addinviter_layers  *int32
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Event, error)
	predicates         []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id uint32) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *EventMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *EventMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *EventMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *EventMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EventMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EventMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *EventMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *EventMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *EventMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *EventMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *EventMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *EventMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *EventMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *EventMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[event.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *EventMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[event.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *EventMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, event.FieldAppID)
}

// SetEventType sets the "event_type" field.
func (m *EventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *EventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ClearEventType clears the value of the "event_type" field.
func (m *EventMutation) ClearEventType() {
	m.event_type = nil
	m.clearedFields[event.FieldEventType] = struct{}{}
}

// EventTypeCleared returns if the "event_type" field was cleared in this mutation.
func (m *EventMutation) EventTypeCleared() bool {
	_, ok := m.clearedFields[event.FieldEventType]
	return ok
}

// ResetEventType resets all changes to the "event_type" field.
func (m *EventMutation) ResetEventType() {
	m.event_type = nil
	delete(m.clearedFields, event.FieldEventType)
}

// SetCouponIds sets the "coupon_ids" field.
func (m *EventMutation) SetCouponIds(u []uuid.UUID) {
	m.coupon_ids = &u
}

// CouponIds returns the value of the "coupon_ids" field in the mutation.
func (m *EventMutation) CouponIds() (r []uuid.UUID, exists bool) {
	v := m.coupon_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponIds returns the old "coupon_ids" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCouponIds(ctx context.Context) (v []uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponIds: %w", err)
	}
	return oldValue.CouponIds, nil
}

// ClearCouponIds clears the value of the "coupon_ids" field.
func (m *EventMutation) ClearCouponIds() {
	m.coupon_ids = nil
	m.clearedFields[event.FieldCouponIds] = struct{}{}
}

// CouponIdsCleared returns if the "coupon_ids" field was cleared in this mutation.
func (m *EventMutation) CouponIdsCleared() bool {
	_, ok := m.clearedFields[event.FieldCouponIds]
	return ok
}

// ResetCouponIds resets all changes to the "coupon_ids" field.
func (m *EventMutation) ResetCouponIds() {
	m.coupon_ids = nil
	delete(m.clearedFields, event.FieldCouponIds)
}

// SetCredits sets the "credits" field.
func (m *EventMutation) SetCredits(d decimal.Decimal) {
	m.credits = &d
}

// Credits returns the value of the "credits" field in the mutation.
func (m *EventMutation) Credits() (r decimal.Decimal, exists bool) {
	v := m.credits
	if v == nil {
		return
	}
	return *v, true
}

// OldCredits returns the old "credits" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCredits(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredits: %w", err)
	}
	return oldValue.Credits, nil
}

// ClearCredits clears the value of the "credits" field.
func (m *EventMutation) ClearCredits() {
	m.credits = nil
	m.clearedFields[event.FieldCredits] = struct{}{}
}

// CreditsCleared returns if the "credits" field was cleared in this mutation.
func (m *EventMutation) CreditsCleared() bool {
	_, ok := m.clearedFields[event.FieldCredits]
	return ok
}

// ResetCredits resets all changes to the "credits" field.
func (m *EventMutation) ResetCredits() {
	m.credits = nil
	delete(m.clearedFields, event.FieldCredits)
}

// SetCreditsPerUsd sets the "credits_per_usd" field.
func (m *EventMutation) SetCreditsPerUsd(d decimal.Decimal) {
	m.credits_per_usd = &d
}

// CreditsPerUsd returns the value of the "credits_per_usd" field in the mutation.
func (m *EventMutation) CreditsPerUsd() (r decimal.Decimal, exists bool) {
	v := m.credits_per_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditsPerUsd returns the old "credits_per_usd" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreditsPerUsd(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditsPerUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditsPerUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditsPerUsd: %w", err)
	}
	return oldValue.CreditsPerUsd, nil
}

// ClearCreditsPerUsd clears the value of the "credits_per_usd" field.
func (m *EventMutation) ClearCreditsPerUsd() {
	m.credits_per_usd = nil
	m.clearedFields[event.FieldCreditsPerUsd] = struct{}{}
}

// CreditsPerUsdCleared returns if the "credits_per_usd" field was cleared in this mutation.
func (m *EventMutation) CreditsPerUsdCleared() bool {
	_, ok := m.clearedFields[event.FieldCreditsPerUsd]
	return ok
}

// ResetCreditsPerUsd resets all changes to the "credits_per_usd" field.
func (m *EventMutation) ResetCreditsPerUsd() {
	m.credits_per_usd = nil
	delete(m.clearedFields, event.FieldCreditsPerUsd)
}

// SetMaxConsecutive sets the "max_consecutive" field.
func (m *EventMutation) SetMaxConsecutive(u uint32) {
	m.max_consecutive = &u
	m.addmax_consecutive = nil
}

// MaxConsecutive returns the value of the "max_consecutive" field in the mutation.
func (m *EventMutation) MaxConsecutive() (r uint32, exists bool) {
	v := m.max_consecutive
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxConsecutive returns the old "max_consecutive" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMaxConsecutive(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxConsecutive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxConsecutive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxConsecutive: %w", err)
	}
	return oldValue.MaxConsecutive, nil
}

// AddMaxConsecutive adds u to the "max_consecutive" field.
func (m *EventMutation) AddMaxConsecutive(u int32) {
	if m.addmax_consecutive != nil {
		*m.addmax_consecutive += u
	} else {
		m.addmax_consecutive = &u
	}
}

// AddedMaxConsecutive returns the value that was added to the "max_consecutive" field in this mutation.
func (m *EventMutation) AddedMaxConsecutive() (r int32, exists bool) {
	v := m.addmax_consecutive
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxConsecutive clears the value of the "max_consecutive" field.
func (m *EventMutation) ClearMaxConsecutive() {
	m.max_consecutive = nil
	m.addmax_consecutive = nil
	m.clearedFields[event.FieldMaxConsecutive] = struct{}{}
}

// MaxConsecutiveCleared returns if the "max_consecutive" field was cleared in this mutation.
func (m *EventMutation) MaxConsecutiveCleared() bool {
	_, ok := m.clearedFields[event.FieldMaxConsecutive]
	return ok
}

// ResetMaxConsecutive resets all changes to the "max_consecutive" field.
func (m *EventMutation) ResetMaxConsecutive() {
	m.max_consecutive = nil
	m.addmax_consecutive = nil
	delete(m.clearedFields, event.FieldMaxConsecutive)
}

// SetGoodID sets the "good_id" field.
func (m *EventMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *EventMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *EventMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[event.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *EventMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[event.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *EventMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, event.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *EventMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *EventMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *EventMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[event.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *EventMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[event.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *EventMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, event.FieldAppGoodID)
}

// SetInviterLayers sets the "inviter_layers" field.
func (m *EventMutation) SetInviterLayers(u uint32) {
	m.inviter_layers = &u
	m.addinviter_layers = nil
}

// InviterLayers returns the value of the "inviter_layers" field in the mutation.
func (m *EventMutation) InviterLayers() (r uint32, exists bool) {
	v := m.inviter_layers
	if v == nil {
		return
	}
	return *v, true
}

// OldInviterLayers returns the old "inviter_layers" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldInviterLayers(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviterLayers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviterLayers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviterLayers: %w", err)
	}
	return oldValue.InviterLayers, nil
}

// AddInviterLayers adds u to the "inviter_layers" field.
func (m *EventMutation) AddInviterLayers(u int32) {
	if m.addinviter_layers != nil {
		*m.addinviter_layers += u
	} else {
		m.addinviter_layers = &u
	}
}

// AddedInviterLayers returns the value that was added to the "inviter_layers" field in this mutation.
func (m *EventMutation) AddedInviterLayers() (r int32, exists bool) {
	v := m.addinviter_layers
	if v == nil {
		return
	}
	return *v, true
}

// ClearInviterLayers clears the value of the "inviter_layers" field.
func (m *EventMutation) ClearInviterLayers() {
	m.inviter_layers = nil
	m.addinviter_layers = nil
	m.clearedFields[event.FieldInviterLayers] = struct{}{}
}

// InviterLayersCleared returns if the "inviter_layers" field was cleared in this mutation.
func (m *EventMutation) InviterLayersCleared() bool {
	_, ok := m.clearedFields[event.FieldInviterLayers]
	return ok
}

// ResetInviterLayers resets all changes to the "inviter_layers" field.
func (m *EventMutation) ResetInviterLayers() {
	m.inviter_layers = nil
	m.addinviter_layers = nil
	delete(m.clearedFields, event.FieldInviterLayers)
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, event.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, event.FieldAppID)
	}
	if m.event_type != nil {
		fields = append(fields, event.FieldEventType)
	}
	if m.coupon_ids != nil {
		fields = append(fields, event.FieldCouponIds)
	}
	if m.credits != nil {
		fields = append(fields, event.FieldCredits)
	}
	if m.credits_per_usd != nil {
		fields = append(fields, event.FieldCreditsPerUsd)
	}
	if m.max_consecutive != nil {
		fields = append(fields, event.FieldMaxConsecutive)
	}
	if m.good_id != nil {
		fields = append(fields, event.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, event.FieldAppGoodID)
	}
	if m.inviter_layers != nil {
		fields = append(fields, event.FieldInviterLayers)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	case event.FieldDeletedAt:
		return m.DeletedAt()
	case event.FieldEntID:
		return m.EntID()
	case event.FieldAppID:
		return m.AppID()
	case event.FieldEventType:
		return m.EventType()
	case event.FieldCouponIds:
		return m.CouponIds()
	case event.FieldCredits:
		return m.Credits()
	case event.FieldCreditsPerUsd:
		return m.CreditsPerUsd()
	case event.FieldMaxConsecutive:
		return m.MaxConsecutive()
	case event.FieldGoodID:
		return m.GoodID()
	case event.FieldAppGoodID:
		return m.AppGoodID()
	case event.FieldInviterLayers:
		return m.InviterLayers()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case event.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case event.FieldEntID:
		return m.OldEntID(ctx)
	case event.FieldAppID:
		return m.OldAppID(ctx)
	case event.FieldEventType:
		return m.OldEventType(ctx)
	case event.FieldCouponIds:
		return m.OldCouponIds(ctx)
	case event.FieldCredits:
		return m.OldCredits(ctx)
	case event.FieldCreditsPerUsd:
		return m.OldCreditsPerUsd(ctx)
	case event.FieldMaxConsecutive:
		return m.OldMaxConsecutive(ctx)
	case event.FieldGoodID:
		return m.OldGoodID(ctx)
	case event.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case event.FieldInviterLayers:
		return m.OldInviterLayers(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case event.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case event.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case event.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case event.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case event.FieldCouponIds:
		v, ok := value.([]uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponIds(v)
		return nil
	case event.FieldCredits:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredits(v)
		return nil
	case event.FieldCreditsPerUsd:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditsPerUsd(v)
		return nil
	case event.FieldMaxConsecutive:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxConsecutive(v)
		return nil
	case event.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case event.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case event.FieldInviterLayers:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviterLayers(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.addmax_consecutive != nil {
		fields = append(fields, event.FieldMaxConsecutive)
	}
	if m.addinviter_layers != nil {
		fields = append(fields, event.FieldInviterLayers)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreatedAt:
		return m.AddedCreatedAt()
	case event.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case event.FieldDeletedAt:
		return m.AddedDeletedAt()
	case event.FieldMaxConsecutive:
		return m.AddedMaxConsecutive()
	case event.FieldInviterLayers:
		return m.AddedInviterLayers()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case event.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case event.FieldMaxConsecutive:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxConsecutive(v)
		return nil
	case event.FieldInviterLayers:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInviterLayers(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldAppID) {
		fields = append(fields, event.FieldAppID)
	}
	if m.FieldCleared(event.FieldEventType) {
		fields = append(fields, event.FieldEventType)
	}
	if m.FieldCleared(event.FieldCouponIds) {
		fields = append(fields, event.FieldCouponIds)
	}
	if m.FieldCleared(event.FieldCredits) {
		fields = append(fields, event.FieldCredits)
	}
	if m.FieldCleared(event.FieldCreditsPerUsd) {
		fields = append(fields, event.FieldCreditsPerUsd)
	}
	if m.FieldCleared(event.FieldMaxConsecutive) {
		fields = append(fields, event.FieldMaxConsecutive)
	}
	if m.FieldCleared(event.FieldGoodID) {
		fields = append(fields, event.FieldGoodID)
	}
	if m.FieldCleared(event.FieldAppGoodID) {
		fields = append(fields, event.FieldAppGoodID)
	}
	if m.FieldCleared(event.FieldInviterLayers) {
		fields = append(fields, event.FieldInviterLayers)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldAppID:
		m.ClearAppID()
		return nil
	case event.FieldEventType:
		m.ClearEventType()
		return nil
	case event.FieldCouponIds:
		m.ClearCouponIds()
		return nil
	case event.FieldCredits:
		m.ClearCredits()
		return nil
	case event.FieldCreditsPerUsd:
		m.ClearCreditsPerUsd()
		return nil
	case event.FieldMaxConsecutive:
		m.ClearMaxConsecutive()
		return nil
	case event.FieldGoodID:
		m.ClearGoodID()
		return nil
	case event.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case event.FieldInviterLayers:
		m.ClearInviterLayers()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case event.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case event.FieldEntID:
		m.ResetEntID()
		return nil
	case event.FieldAppID:
		m.ResetAppID()
		return nil
	case event.FieldEventType:
		m.ResetEventType()
		return nil
	case event.FieldCouponIds:
		m.ResetCouponIds()
		return nil
	case event.FieldCredits:
		m.ResetCredits()
		return nil
	case event.FieldCreditsPerUsd:
		m.ResetCreditsPerUsd()
		return nil
	case event.FieldMaxConsecutive:
		m.ResetMaxConsecutive()
		return nil
	case event.FieldGoodID:
		m.ResetGoodID()
		return nil
	case event.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case event.FieldInviterLayers:
		m.ResetInviterLayers()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Event edge %s", name)
}

// InvitationCodeMutation represents an operation that mutates the InvitationCode nodes in the graph.
type InvitationCodeMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	ent_id          *uuid.UUID
	app_id          *uuid.UUID
	user_id         *uuid.UUID
	invitation_code *string
	disabled        *bool
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*InvitationCode, error)
	predicates      []predicate.InvitationCode
}

var _ ent.Mutation = (*InvitationCodeMutation)(nil)

// invitationcodeOption allows management of the mutation configuration using functional options.
type invitationcodeOption func(*InvitationCodeMutation)

// newInvitationCodeMutation creates new mutation for the InvitationCode entity.
func newInvitationCodeMutation(c config, op Op, opts ...invitationcodeOption) *InvitationCodeMutation {
	m := &InvitationCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitationCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationCodeID sets the ID field of the mutation.
func withInvitationCodeID(id uuid.UUID) invitationcodeOption {
	return func(m *InvitationCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *InvitationCode
		)
		m.oldValue = func(ctx context.Context) (*InvitationCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvitationCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitationCode sets the old InvitationCode of the mutation.
func withInvitationCode(node *InvitationCode) invitationcodeOption {
	return func(m *InvitationCodeMutation) {
		m.oldValue = func(context.Context) (*InvitationCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvitationCode entities.
func (m *InvitationCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvitationCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InvitationCodeMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvitationCodeMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *InvitationCodeMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *InvitationCodeMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvitationCodeMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvitationCodeMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvitationCodeMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *InvitationCodeMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *InvitationCodeMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvitationCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InvitationCodeMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InvitationCodeMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *InvitationCodeMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *InvitationCodeMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InvitationCodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *InvitationCodeMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *InvitationCodeMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *InvitationCodeMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *InvitationCodeMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *InvitationCodeMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *InvitationCodeMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[invitationcode.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *InvitationCodeMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[invitationcode.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *InvitationCodeMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, invitationcode.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *InvitationCodeMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InvitationCodeMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *InvitationCodeMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[invitationcode.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *InvitationCodeMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[invitationcode.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InvitationCodeMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, invitationcode.FieldUserID)
}

// SetInvitationCode sets the "invitation_code" field.
func (m *InvitationCodeMutation) SetInvitationCode(s string) {
	m.invitation_code = &s
}

// InvitationCode returns the value of the "invitation_code" field in the mutation.
func (m *InvitationCodeMutation) InvitationCode() (r string, exists bool) {
	v := m.invitation_code
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationCode returns the old "invitation_code" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldInvitationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationCode: %w", err)
	}
	return oldValue.InvitationCode, nil
}

// ClearInvitationCode clears the value of the "invitation_code" field.
func (m *InvitationCodeMutation) ClearInvitationCode() {
	m.invitation_code = nil
	m.clearedFields[invitationcode.FieldInvitationCode] = struct{}{}
}

// InvitationCodeCleared returns if the "invitation_code" field was cleared in this mutation.
func (m *InvitationCodeMutation) InvitationCodeCleared() bool {
	_, ok := m.clearedFields[invitationcode.FieldInvitationCode]
	return ok
}

// ResetInvitationCode resets all changes to the "invitation_code" field.
func (m *InvitationCodeMutation) ResetInvitationCode() {
	m.invitation_code = nil
	delete(m.clearedFields, invitationcode.FieldInvitationCode)
}

// SetDisabled sets the "disabled" field.
func (m *InvitationCodeMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *InvitationCodeMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the InvitationCode entity.
// If the InvitationCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationCodeMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *InvitationCodeMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[invitationcode.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *InvitationCodeMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[invitationcode.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *InvitationCodeMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, invitationcode.FieldDisabled)
}

// Where appends a list predicates to the InvitationCodeMutation builder.
func (m *InvitationCodeMutation) Where(ps ...predicate.InvitationCode) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InvitationCodeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InvitationCode).
func (m *InvitationCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationCodeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, invitationcode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invitationcode.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, invitationcode.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, invitationcode.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, invitationcode.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, invitationcode.FieldUserID)
	}
	if m.invitation_code != nil {
		fields = append(fields, invitationcode.FieldInvitationCode)
	}
	if m.disabled != nil {
		fields = append(fields, invitationcode.FieldDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitationcode.FieldCreatedAt:
		return m.CreatedAt()
	case invitationcode.FieldUpdatedAt:
		return m.UpdatedAt()
	case invitationcode.FieldDeletedAt:
		return m.DeletedAt()
	case invitationcode.FieldEntID:
		return m.EntID()
	case invitationcode.FieldAppID:
		return m.AppID()
	case invitationcode.FieldUserID:
		return m.UserID()
	case invitationcode.FieldInvitationCode:
		return m.InvitationCode()
	case invitationcode.FieldDisabled:
		return m.Disabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitationcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invitationcode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invitationcode.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case invitationcode.FieldEntID:
		return m.OldEntID(ctx)
	case invitationcode.FieldAppID:
		return m.OldAppID(ctx)
	case invitationcode.FieldUserID:
		return m.OldUserID(ctx)
	case invitationcode.FieldInvitationCode:
		return m.OldInvitationCode(ctx)
	case invitationcode.FieldDisabled:
		return m.OldDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown InvitationCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitationcode.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invitationcode.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invitationcode.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case invitationcode.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case invitationcode.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case invitationcode.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case invitationcode.FieldInvitationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationCode(v)
		return nil
	case invitationcode.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown InvitationCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationCodeMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, invitationcode.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, invitationcode.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, invitationcode.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invitationcode.FieldCreatedAt:
		return m.AddedCreatedAt()
	case invitationcode.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case invitationcode.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invitationcode.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case invitationcode.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case invitationcode.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InvitationCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invitationcode.FieldAppID) {
		fields = append(fields, invitationcode.FieldAppID)
	}
	if m.FieldCleared(invitationcode.FieldUserID) {
		fields = append(fields, invitationcode.FieldUserID)
	}
	if m.FieldCleared(invitationcode.FieldInvitationCode) {
		fields = append(fields, invitationcode.FieldInvitationCode)
	}
	if m.FieldCleared(invitationcode.FieldDisabled) {
		fields = append(fields, invitationcode.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationCodeMutation) ClearField(name string) error {
	switch name {
	case invitationcode.FieldAppID:
		m.ClearAppID()
		return nil
	case invitationcode.FieldUserID:
		m.ClearUserID()
		return nil
	case invitationcode.FieldInvitationCode:
		m.ClearInvitationCode()
		return nil
	case invitationcode.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown InvitationCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationCodeMutation) ResetField(name string) error {
	switch name {
	case invitationcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invitationcode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invitationcode.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case invitationcode.FieldEntID:
		m.ResetEntID()
		return nil
	case invitationcode.FieldAppID:
		m.ResetAppID()
		return nil
	case invitationcode.FieldUserID:
		m.ResetUserID()
		return nil
	case invitationcode.FieldInvitationCode:
		m.ResetInvitationCode()
		return nil
	case invitationcode.FieldDisabled:
		m.ResetDisabled()
		return nil
	}
	return fmt.Errorf("unknown InvitationCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationCodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationCodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationCodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InvitationCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationCodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InvitationCode edge %s", name)
}

// PubsubMessageMutation represents an operation that mutates the PubsubMessage nodes in the graph.
type PubsubMessageMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	message_id    *string
	state         *string
	resp_to_id    *uuid.UUID
	undo_id       *uuid.UUID
	arguments     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PubsubMessage, error)
	predicates    []predicate.PubsubMessage
}

var _ ent.Mutation = (*PubsubMessageMutation)(nil)

// pubsubmessageOption allows management of the mutation configuration using functional options.
type pubsubmessageOption func(*PubsubMessageMutation)

// newPubsubMessageMutation creates new mutation for the PubsubMessage entity.
func newPubsubMessageMutation(c config, op Op, opts ...pubsubmessageOption) *PubsubMessageMutation {
	m := &PubsubMessageMutation{
		config:        c,
		op:            op,
		typ:           TypePubsubMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPubsubMessageID sets the ID field of the mutation.
func withPubsubMessageID(id uuid.UUID) pubsubmessageOption {
	return func(m *PubsubMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *PubsubMessage
		)
		m.oldValue = func(ctx context.Context) (*PubsubMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PubsubMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPubsubMessage sets the old PubsubMessage of the mutation.
func withPubsubMessage(node *PubsubMessage) pubsubmessageOption {
	return func(m *PubsubMessageMutation) {
		m.oldValue = func(context.Context) (*PubsubMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PubsubMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PubsubMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PubsubMessage entities.
func (m *PubsubMessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PubsubMessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PubsubMessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PubsubMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PubsubMessageMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PubsubMessageMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PubsubMessage entity.
// If the PubsubMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PubsubMessageMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *PubsubMessageMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PubsubMessageMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PubsubMessageMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PubsubMessageMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PubsubMessageMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PubsubMessage entity.
// If the PubsubMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PubsubMessageMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *PubsubMessageMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PubsubMessageMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PubsubMessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PubsubMessageMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PubsubMessageMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PubsubMessage entity.
// If the PubsubMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PubsubMessageMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *PubsubMessageMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PubsubMessageMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PubsubMessageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetMessageID sets the "message_id" field.
func (m *PubsubMessageMutation) SetMessageID(s string) {
	m.message_id = &s
}

// MessageID returns the value of the "message_id" field in the mutation.
func (m *PubsubMessageMutation) MessageID() (r string, exists bool) {
	v := m.message_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageID returns the old "message_id" field's value of the PubsubMessage entity.
// If the PubsubMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PubsubMessageMutation) OldMessageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageID: %w", err)
	}
	return oldValue.MessageID, nil
}

// ClearMessageID clears the value of the "message_id" field.
func (m *PubsubMessageMutation) ClearMessageID() {
	m.message_id = nil
	m.clearedFields[pubsubmessage.FieldMessageID] = struct{}{}
}

// MessageIDCleared returns if the "message_id" field was cleared in this mutation.
func (m *PubsubMessageMutation) MessageIDCleared() bool {
	_, ok := m.clearedFields[pubsubmessage.FieldMessageID]
	return ok
}

// ResetMessageID resets all changes to the "message_id" field.
func (m *PubsubMessageMutation) ResetMessageID() {
	m.message_id = nil
	delete(m.clearedFields, pubsubmessage.FieldMessageID)
}

// SetState sets the "state" field.
func (m *PubsubMessageMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *PubsubMessageMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the PubsubMessage entity.
// If the PubsubMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PubsubMessageMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *PubsubMessageMutation) ClearState() {
	m.state = nil
	m.clearedFields[pubsubmessage.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *PubsubMessageMutation) StateCleared() bool {
	_, ok := m.clearedFields[pubsubmessage.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *PubsubMessageMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, pubsubmessage.FieldState)
}

// SetRespToID sets the "resp_to_id" field.
func (m *PubsubMessageMutation) SetRespToID(u uuid.UUID) {
	m.resp_to_id = &u
}

// RespToID returns the value of the "resp_to_id" field in the mutation.
func (m *PubsubMessageMutation) RespToID() (r uuid.UUID, exists bool) {
	v := m.resp_to_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRespToID returns the old "resp_to_id" field's value of the PubsubMessage entity.
// If the PubsubMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PubsubMessageMutation) OldRespToID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespToID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespToID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespToID: %w", err)
	}
	return oldValue.RespToID, nil
}

// ClearRespToID clears the value of the "resp_to_id" field.
func (m *PubsubMessageMutation) ClearRespToID() {
	m.resp_to_id = nil
	m.clearedFields[pubsubmessage.FieldRespToID] = struct{}{}
}

// RespToIDCleared returns if the "resp_to_id" field was cleared in this mutation.
func (m *PubsubMessageMutation) RespToIDCleared() bool {
	_, ok := m.clearedFields[pubsubmessage.FieldRespToID]
	return ok
}

// ResetRespToID resets all changes to the "resp_to_id" field.
func (m *PubsubMessageMutation) ResetRespToID() {
	m.resp_to_id = nil
	delete(m.clearedFields, pubsubmessage.FieldRespToID)
}

// SetUndoID sets the "undo_id" field.
func (m *PubsubMessageMutation) SetUndoID(u uuid.UUID) {
	m.undo_id = &u
}

// UndoID returns the value of the "undo_id" field in the mutation.
func (m *PubsubMessageMutation) UndoID() (r uuid.UUID, exists bool) {
	v := m.undo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUndoID returns the old "undo_id" field's value of the PubsubMessage entity.
// If the PubsubMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PubsubMessageMutation) OldUndoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUndoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUndoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUndoID: %w", err)
	}
	return oldValue.UndoID, nil
}

// ClearUndoID clears the value of the "undo_id" field.
func (m *PubsubMessageMutation) ClearUndoID() {
	m.undo_id = nil
	m.clearedFields[pubsubmessage.FieldUndoID] = struct{}{}
}

// UndoIDCleared returns if the "undo_id" field was cleared in this mutation.
func (m *PubsubMessageMutation) UndoIDCleared() bool {
	_, ok := m.clearedFields[pubsubmessage.FieldUndoID]
	return ok
}

// ResetUndoID resets all changes to the "undo_id" field.
func (m *PubsubMessageMutation) ResetUndoID() {
	m.undo_id = nil
	delete(m.clearedFields, pubsubmessage.FieldUndoID)
}

// SetArguments sets the "arguments" field.
func (m *PubsubMessageMutation) SetArguments(s string) {
	m.arguments = &s
}

// Arguments returns the value of the "arguments" field in the mutation.
func (m *PubsubMessageMutation) Arguments() (r string, exists bool) {
	v := m.arguments
	if v == nil {
		return
	}
	return *v, true
}

// OldArguments returns the old "arguments" field's value of the PubsubMessage entity.
// If the PubsubMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PubsubMessageMutation) OldArguments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArguments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArguments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArguments: %w", err)
	}
	return oldValue.Arguments, nil
}

// ClearArguments clears the value of the "arguments" field.
func (m *PubsubMessageMutation) ClearArguments() {
	m.arguments = nil
	m.clearedFields[pubsubmessage.FieldArguments] = struct{}{}
}

// ArgumentsCleared returns if the "arguments" field was cleared in this mutation.
func (m *PubsubMessageMutation) ArgumentsCleared() bool {
	_, ok := m.clearedFields[pubsubmessage.FieldArguments]
	return ok
}

// ResetArguments resets all changes to the "arguments" field.
func (m *PubsubMessageMutation) ResetArguments() {
	m.arguments = nil
	delete(m.clearedFields, pubsubmessage.FieldArguments)
}

// Where appends a list predicates to the PubsubMessageMutation builder.
func (m *PubsubMessageMutation) Where(ps ...predicate.PubsubMessage) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PubsubMessageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PubsubMessage).
func (m *PubsubMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PubsubMessageMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, pubsubmessage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pubsubmessage.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, pubsubmessage.FieldDeletedAt)
	}
	if m.message_id != nil {
		fields = append(fields, pubsubmessage.FieldMessageID)
	}
	if m.state != nil {
		fields = append(fields, pubsubmessage.FieldState)
	}
	if m.resp_to_id != nil {
		fields = append(fields, pubsubmessage.FieldRespToID)
	}
	if m.undo_id != nil {
		fields = append(fields, pubsubmessage.FieldUndoID)
	}
	if m.arguments != nil {
		fields = append(fields, pubsubmessage.FieldArguments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PubsubMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pubsubmessage.FieldCreatedAt:
		return m.CreatedAt()
	case pubsubmessage.FieldUpdatedAt:
		return m.UpdatedAt()
	case pubsubmessage.FieldDeletedAt:
		return m.DeletedAt()
	case pubsubmessage.FieldMessageID:
		return m.MessageID()
	case pubsubmessage.FieldState:
		return m.State()
	case pubsubmessage.FieldRespToID:
		return m.RespToID()
	case pubsubmessage.FieldUndoID:
		return m.UndoID()
	case pubsubmessage.FieldArguments:
		return m.Arguments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PubsubMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pubsubmessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pubsubmessage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pubsubmessage.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case pubsubmessage.FieldMessageID:
		return m.OldMessageID(ctx)
	case pubsubmessage.FieldState:
		return m.OldState(ctx)
	case pubsubmessage.FieldRespToID:
		return m.OldRespToID(ctx)
	case pubsubmessage.FieldUndoID:
		return m.OldUndoID(ctx)
	case pubsubmessage.FieldArguments:
		return m.OldArguments(ctx)
	}
	return nil, fmt.Errorf("unknown PubsubMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PubsubMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pubsubmessage.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pubsubmessage.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pubsubmessage.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case pubsubmessage.FieldMessageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageID(v)
		return nil
	case pubsubmessage.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case pubsubmessage.FieldRespToID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespToID(v)
		return nil
	case pubsubmessage.FieldUndoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUndoID(v)
		return nil
	case pubsubmessage.FieldArguments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArguments(v)
		return nil
	}
	return fmt.Errorf("unknown PubsubMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PubsubMessageMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, pubsubmessage.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, pubsubmessage.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, pubsubmessage.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PubsubMessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pubsubmessage.FieldCreatedAt:
		return m.AddedCreatedAt()
	case pubsubmessage.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case pubsubmessage.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PubsubMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pubsubmessage.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case pubsubmessage.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case pubsubmessage.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PubsubMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PubsubMessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pubsubmessage.FieldMessageID) {
		fields = append(fields, pubsubmessage.FieldMessageID)
	}
	if m.FieldCleared(pubsubmessage.FieldState) {
		fields = append(fields, pubsubmessage.FieldState)
	}
	if m.FieldCleared(pubsubmessage.FieldRespToID) {
		fields = append(fields, pubsubmessage.FieldRespToID)
	}
	if m.FieldCleared(pubsubmessage.FieldUndoID) {
		fields = append(fields, pubsubmessage.FieldUndoID)
	}
	if m.FieldCleared(pubsubmessage.FieldArguments) {
		fields = append(fields, pubsubmessage.FieldArguments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PubsubMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PubsubMessageMutation) ClearField(name string) error {
	switch name {
	case pubsubmessage.FieldMessageID:
		m.ClearMessageID()
		return nil
	case pubsubmessage.FieldState:
		m.ClearState()
		return nil
	case pubsubmessage.FieldRespToID:
		m.ClearRespToID()
		return nil
	case pubsubmessage.FieldUndoID:
		m.ClearUndoID()
		return nil
	case pubsubmessage.FieldArguments:
		m.ClearArguments()
		return nil
	}
	return fmt.Errorf("unknown PubsubMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PubsubMessageMutation) ResetField(name string) error {
	switch name {
	case pubsubmessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pubsubmessage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pubsubmessage.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case pubsubmessage.FieldMessageID:
		m.ResetMessageID()
		return nil
	case pubsubmessage.FieldState:
		m.ResetState()
		return nil
	case pubsubmessage.FieldRespToID:
		m.ResetRespToID()
		return nil
	case pubsubmessage.FieldUndoID:
		m.ResetUndoID()
		return nil
	case pubsubmessage.FieldArguments:
		m.ResetArguments()
		return nil
	}
	return fmt.Errorf("unknown PubsubMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PubsubMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PubsubMessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PubsubMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PubsubMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PubsubMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PubsubMessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PubsubMessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PubsubMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PubsubMessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PubsubMessage edge %s", name)
}

// RegistrationMutation represents an operation that mutates the Registration nodes in the graph.
type RegistrationMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	inviter_id    *uuid.UUID
	invitee_id    *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Registration, error)
	predicates    []predicate.Registration
}

var _ ent.Mutation = (*RegistrationMutation)(nil)

// registrationOption allows management of the mutation configuration using functional options.
type registrationOption func(*RegistrationMutation)

// newRegistrationMutation creates new mutation for the Registration entity.
func newRegistrationMutation(c config, op Op, opts ...registrationOption) *RegistrationMutation {
	m := &RegistrationMutation{
		config:        c,
		op:            op,
		typ:           TypeRegistration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegistrationID sets the ID field of the mutation.
func withRegistrationID(id uuid.UUID) registrationOption {
	return func(m *RegistrationMutation) {
		var (
			err   error
			once  sync.Once
			value *Registration
		)
		m.oldValue = func(ctx context.Context) (*Registration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Registration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegistration sets the old Registration of the mutation.
func withRegistration(node *Registration) registrationOption {
	return func(m *RegistrationMutation) {
		m.oldValue = func(context.Context) (*Registration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegistrationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegistrationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Registration entities.
func (m *RegistrationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RegistrationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RegistrationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Registration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RegistrationMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RegistrationMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *RegistrationMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RegistrationMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RegistrationMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RegistrationMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RegistrationMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *RegistrationMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RegistrationMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RegistrationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RegistrationMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RegistrationMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *RegistrationMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RegistrationMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RegistrationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *RegistrationMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *RegistrationMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *RegistrationMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *RegistrationMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *RegistrationMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *RegistrationMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[registration.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *RegistrationMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[registration.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *RegistrationMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, registration.FieldAppID)
}

// SetInviterID sets the "inviter_id" field.
func (m *RegistrationMutation) SetInviterID(u uuid.UUID) {
	m.inviter_id = &u
}

// InviterID returns the value of the "inviter_id" field in the mutation.
func (m *RegistrationMutation) InviterID() (r uuid.UUID, exists bool) {
	v := m.inviter_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInviterID returns the old "inviter_id" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldInviterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviterID: %w", err)
	}
	return oldValue.InviterID, nil
}

// ClearInviterID clears the value of the "inviter_id" field.
func (m *RegistrationMutation) ClearInviterID() {
	m.inviter_id = nil
	m.clearedFields[registration.FieldInviterID] = struct{}{}
}

// InviterIDCleared returns if the "inviter_id" field was cleared in this mutation.
func (m *RegistrationMutation) InviterIDCleared() bool {
	_, ok := m.clearedFields[registration.FieldInviterID]
	return ok
}

// ResetInviterID resets all changes to the "inviter_id" field.
func (m *RegistrationMutation) ResetInviterID() {
	m.inviter_id = nil
	delete(m.clearedFields, registration.FieldInviterID)
}

// SetInviteeID sets the "invitee_id" field.
func (m *RegistrationMutation) SetInviteeID(u uuid.UUID) {
	m.invitee_id = &u
}

// InviteeID returns the value of the "invitee_id" field in the mutation.
func (m *RegistrationMutation) InviteeID() (r uuid.UUID, exists bool) {
	v := m.invitee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteeID returns the old "invitee_id" field's value of the Registration entity.
// If the Registration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegistrationMutation) OldInviteeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteeID: %w", err)
	}
	return oldValue.InviteeID, nil
}

// ClearInviteeID clears the value of the "invitee_id" field.
func (m *RegistrationMutation) ClearInviteeID() {
	m.invitee_id = nil
	m.clearedFields[registration.FieldInviteeID] = struct{}{}
}

// InviteeIDCleared returns if the "invitee_id" field was cleared in this mutation.
func (m *RegistrationMutation) InviteeIDCleared() bool {
	_, ok := m.clearedFields[registration.FieldInviteeID]
	return ok
}

// ResetInviteeID resets all changes to the "invitee_id" field.
func (m *RegistrationMutation) ResetInviteeID() {
	m.invitee_id = nil
	delete(m.clearedFields, registration.FieldInviteeID)
}

// Where appends a list predicates to the RegistrationMutation builder.
func (m *RegistrationMutation) Where(ps ...predicate.Registration) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RegistrationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Registration).
func (m *RegistrationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RegistrationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, registration.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, registration.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, registration.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, registration.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, registration.FieldAppID)
	}
	if m.inviter_id != nil {
		fields = append(fields, registration.FieldInviterID)
	}
	if m.invitee_id != nil {
		fields = append(fields, registration.FieldInviteeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RegistrationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case registration.FieldCreatedAt:
		return m.CreatedAt()
	case registration.FieldUpdatedAt:
		return m.UpdatedAt()
	case registration.FieldDeletedAt:
		return m.DeletedAt()
	case registration.FieldEntID:
		return m.EntID()
	case registration.FieldAppID:
		return m.AppID()
	case registration.FieldInviterID:
		return m.InviterID()
	case registration.FieldInviteeID:
		return m.InviteeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RegistrationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case registration.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case registration.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case registration.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case registration.FieldEntID:
		return m.OldEntID(ctx)
	case registration.FieldAppID:
		return m.OldAppID(ctx)
	case registration.FieldInviterID:
		return m.OldInviterID(ctx)
	case registration.FieldInviteeID:
		return m.OldInviteeID(ctx)
	}
	return nil, fmt.Errorf("unknown Registration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegistrationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case registration.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case registration.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case registration.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case registration.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case registration.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case registration.FieldInviterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviterID(v)
		return nil
	case registration.FieldInviteeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteeID(v)
		return nil
	}
	return fmt.Errorf("unknown Registration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RegistrationMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, registration.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, registration.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, registration.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RegistrationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case registration.FieldCreatedAt:
		return m.AddedCreatedAt()
	case registration.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case registration.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegistrationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case registration.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case registration.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case registration.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Registration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RegistrationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(registration.FieldAppID) {
		fields = append(fields, registration.FieldAppID)
	}
	if m.FieldCleared(registration.FieldInviterID) {
		fields = append(fields, registration.FieldInviterID)
	}
	if m.FieldCleared(registration.FieldInviteeID) {
		fields = append(fields, registration.FieldInviteeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RegistrationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegistrationMutation) ClearField(name string) error {
	switch name {
	case registration.FieldAppID:
		m.ClearAppID()
		return nil
	case registration.FieldInviterID:
		m.ClearInviterID()
		return nil
	case registration.FieldInviteeID:
		m.ClearInviteeID()
		return nil
	}
	return fmt.Errorf("unknown Registration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RegistrationMutation) ResetField(name string) error {
	switch name {
	case registration.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case registration.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case registration.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case registration.FieldEntID:
		m.ResetEntID()
		return nil
	case registration.FieldAppID:
		m.ResetAppID()
		return nil
	case registration.FieldInviterID:
		m.ResetInviterID()
		return nil
	case registration.FieldInviteeID:
		m.ResetInviteeID()
		return nil
	}
	return fmt.Errorf("unknown Registration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RegistrationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RegistrationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RegistrationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RegistrationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RegistrationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RegistrationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RegistrationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Registration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RegistrationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Registration edge %s", name)
}

// StatementMutation represents an operation that mutates the Statement nodes in the graph.
type StatementMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint32
	created_at                *uint32
	addcreated_at             *int32
	updated_at                *uint32
	addupdated_at             *int32
	deleted_at                *uint32
	adddeleted_at             *int32
	ent_id                    *uuid.UUID
	app_id                    *uuid.UUID
	user_id                   *uuid.UUID
	direct_contributor_id     *uuid.UUID
	good_id                   *uuid.UUID
	app_good_id               *uuid.UUID
	order_id                  *uuid.UUID
	self_order                *bool
	payment_id                *uuid.UUID
	coin_type_id              *uuid.UUID
	payment_coin_type_id      *uuid.UUID
	payment_coin_usd_currency *decimal.Decimal
	units                     *uint32
	addunits                  *int32
	units_v1                  *decimal.Decimal
	amount                    *decimal.Decimal
	usd_amount                *decimal.Decimal
	commission                *decimal.Decimal
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Statement, error)
	predicates                []predicate.Statement
}

var _ ent.Mutation = (*StatementMutation)(nil)

// statementOption allows management of the mutation configuration using functional options.
type statementOption func(*StatementMutation)

// newStatementMutation creates new mutation for the Statement entity.
func newStatementMutation(c config, op Op, opts ...statementOption) *StatementMutation {
	m := &StatementMutation{
		config:        c,
		op:            op,
		typ:           TypeStatement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatementID sets the ID field of the mutation.
func withStatementID(id uint32) statementOption {
	return func(m *StatementMutation) {
		var (
			err   error
			once  sync.Once
			value *Statement
		)
		m.oldValue = func(ctx context.Context) (*Statement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatement sets the old Statement of the mutation.
func withStatement(node *Statement) statementOption {
	return func(m *StatementMutation) {
		m.oldValue = func(context.Context) (*Statement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Statement entities.
func (m *StatementMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatementMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatementMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Statement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StatementMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StatementMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *StatementMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *StatementMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StatementMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StatementMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StatementMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *StatementMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *StatementMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StatementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StatementMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StatementMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *StatementMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *StatementMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StatementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *StatementMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *StatementMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *StatementMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *StatementMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *StatementMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *StatementMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[statement.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *StatementMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *StatementMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, statement.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *StatementMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *StatementMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *StatementMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[statement.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *StatementMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *StatementMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, statement.FieldUserID)
}

// SetDirectContributorID sets the "direct_contributor_id" field.
func (m *StatementMutation) SetDirectContributorID(u uuid.UUID) {
	m.direct_contributor_id = &u
}

// DirectContributorID returns the value of the "direct_contributor_id" field in the mutation.
func (m *StatementMutation) DirectContributorID() (r uuid.UUID, exists bool) {
	v := m.direct_contributor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectContributorID returns the old "direct_contributor_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldDirectContributorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectContributorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectContributorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectContributorID: %w", err)
	}
	return oldValue.DirectContributorID, nil
}

// ClearDirectContributorID clears the value of the "direct_contributor_id" field.
func (m *StatementMutation) ClearDirectContributorID() {
	m.direct_contributor_id = nil
	m.clearedFields[statement.FieldDirectContributorID] = struct{}{}
}

// DirectContributorIDCleared returns if the "direct_contributor_id" field was cleared in this mutation.
func (m *StatementMutation) DirectContributorIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldDirectContributorID]
	return ok
}

// ResetDirectContributorID resets all changes to the "direct_contributor_id" field.
func (m *StatementMutation) ResetDirectContributorID() {
	m.direct_contributor_id = nil
	delete(m.clearedFields, statement.FieldDirectContributorID)
}

// SetGoodID sets the "good_id" field.
func (m *StatementMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *StatementMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ClearGoodID clears the value of the "good_id" field.
func (m *StatementMutation) ClearGoodID() {
	m.good_id = nil
	m.clearedFields[statement.FieldGoodID] = struct{}{}
}

// GoodIDCleared returns if the "good_id" field was cleared in this mutation.
func (m *StatementMutation) GoodIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldGoodID]
	return ok
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *StatementMutation) ResetGoodID() {
	m.good_id = nil
	delete(m.clearedFields, statement.FieldGoodID)
}

// SetAppGoodID sets the "app_good_id" field.
func (m *StatementMutation) SetAppGoodID(u uuid.UUID) {
	m.app_good_id = &u
}

// AppGoodID returns the value of the "app_good_id" field in the mutation.
func (m *StatementMutation) AppGoodID() (r uuid.UUID, exists bool) {
	v := m.app_good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppGoodID returns the old "app_good_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldAppGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppGoodID: %w", err)
	}
	return oldValue.AppGoodID, nil
}

// ClearAppGoodID clears the value of the "app_good_id" field.
func (m *StatementMutation) ClearAppGoodID() {
	m.app_good_id = nil
	m.clearedFields[statement.FieldAppGoodID] = struct{}{}
}

// AppGoodIDCleared returns if the "app_good_id" field was cleared in this mutation.
func (m *StatementMutation) AppGoodIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldAppGoodID]
	return ok
}

// ResetAppGoodID resets all changes to the "app_good_id" field.
func (m *StatementMutation) ResetAppGoodID() {
	m.app_good_id = nil
	delete(m.clearedFields, statement.FieldAppGoodID)
}

// SetOrderID sets the "order_id" field.
func (m *StatementMutation) SetOrderID(u uuid.UUID) {
	m.order_id = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *StatementMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *StatementMutation) ClearOrderID() {
	m.order_id = nil
	m.clearedFields[statement.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *StatementMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *StatementMutation) ResetOrderID() {
	m.order_id = nil
	delete(m.clearedFields, statement.FieldOrderID)
}

// SetSelfOrder sets the "self_order" field.
func (m *StatementMutation) SetSelfOrder(b bool) {
	m.self_order = &b
}

// SelfOrder returns the value of the "self_order" field in the mutation.
func (m *StatementMutation) SelfOrder() (r bool, exists bool) {
	v := m.self_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfOrder returns the old "self_order" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldSelfOrder(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfOrder: %w", err)
	}
	return oldValue.SelfOrder, nil
}

// ClearSelfOrder clears the value of the "self_order" field.
func (m *StatementMutation) ClearSelfOrder() {
	m.self_order = nil
	m.clearedFields[statement.FieldSelfOrder] = struct{}{}
}

// SelfOrderCleared returns if the "self_order" field was cleared in this mutation.
func (m *StatementMutation) SelfOrderCleared() bool {
	_, ok := m.clearedFields[statement.FieldSelfOrder]
	return ok
}

// ResetSelfOrder resets all changes to the "self_order" field.
func (m *StatementMutation) ResetSelfOrder() {
	m.self_order = nil
	delete(m.clearedFields, statement.FieldSelfOrder)
}

// SetPaymentID sets the "payment_id" field.
func (m *StatementMutation) SetPaymentID(u uuid.UUID) {
	m.payment_id = &u
}

// PaymentID returns the value of the "payment_id" field in the mutation.
func (m *StatementMutation) PaymentID() (r uuid.UUID, exists bool) {
	v := m.payment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentID returns the old "payment_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldPaymentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentID: %w", err)
	}
	return oldValue.PaymentID, nil
}

// ClearPaymentID clears the value of the "payment_id" field.
func (m *StatementMutation) ClearPaymentID() {
	m.payment_id = nil
	m.clearedFields[statement.FieldPaymentID] = struct{}{}
}

// PaymentIDCleared returns if the "payment_id" field was cleared in this mutation.
func (m *StatementMutation) PaymentIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldPaymentID]
	return ok
}

// ResetPaymentID resets all changes to the "payment_id" field.
func (m *StatementMutation) ResetPaymentID() {
	m.payment_id = nil
	delete(m.clearedFields, statement.FieldPaymentID)
}

// SetCoinTypeID sets the "coin_type_id" field.
func (m *StatementMutation) SetCoinTypeID(u uuid.UUID) {
	m.coin_type_id = &u
}

// CoinTypeID returns the value of the "coin_type_id" field in the mutation.
func (m *StatementMutation) CoinTypeID() (r uuid.UUID, exists bool) {
	v := m.coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinTypeID returns the old "coin_type_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinTypeID: %w", err)
	}
	return oldValue.CoinTypeID, nil
}

// ClearCoinTypeID clears the value of the "coin_type_id" field.
func (m *StatementMutation) ClearCoinTypeID() {
	m.coin_type_id = nil
	m.clearedFields[statement.FieldCoinTypeID] = struct{}{}
}

// CoinTypeIDCleared returns if the "coin_type_id" field was cleared in this mutation.
func (m *StatementMutation) CoinTypeIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldCoinTypeID]
	return ok
}

// ResetCoinTypeID resets all changes to the "coin_type_id" field.
func (m *StatementMutation) ResetCoinTypeID() {
	m.coin_type_id = nil
	delete(m.clearedFields, statement.FieldCoinTypeID)
}

// SetPaymentCoinTypeID sets the "payment_coin_type_id" field.
func (m *StatementMutation) SetPaymentCoinTypeID(u uuid.UUID) {
	m.payment_coin_type_id = &u
}

// PaymentCoinTypeID returns the value of the "payment_coin_type_id" field in the mutation.
func (m *StatementMutation) PaymentCoinTypeID() (r uuid.UUID, exists bool) {
	v := m.payment_coin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentCoinTypeID returns the old "payment_coin_type_id" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldPaymentCoinTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentCoinTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentCoinTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentCoinTypeID: %w", err)
	}
	return oldValue.PaymentCoinTypeID, nil
}

// ClearPaymentCoinTypeID clears the value of the "payment_coin_type_id" field.
func (m *StatementMutation) ClearPaymentCoinTypeID() {
	m.payment_coin_type_id = nil
	m.clearedFields[statement.FieldPaymentCoinTypeID] = struct{}{}
}

// PaymentCoinTypeIDCleared returns if the "payment_coin_type_id" field was cleared in this mutation.
func (m *StatementMutation) PaymentCoinTypeIDCleared() bool {
	_, ok := m.clearedFields[statement.FieldPaymentCoinTypeID]
	return ok
}

// ResetPaymentCoinTypeID resets all changes to the "payment_coin_type_id" field.
func (m *StatementMutation) ResetPaymentCoinTypeID() {
	m.payment_coin_type_id = nil
	delete(m.clearedFields, statement.FieldPaymentCoinTypeID)
}

// SetPaymentCoinUsdCurrency sets the "payment_coin_usd_currency" field.
func (m *StatementMutation) SetPaymentCoinUsdCurrency(d decimal.Decimal) {
	m.payment_coin_usd_currency = &d
}

// PaymentCoinUsdCurrency returns the value of the "payment_coin_usd_currency" field in the mutation.
func (m *StatementMutation) PaymentCoinUsdCurrency() (r decimal.Decimal, exists bool) {
	v := m.payment_coin_usd_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentCoinUsdCurrency returns the old "payment_coin_usd_currency" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldPaymentCoinUsdCurrency(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentCoinUsdCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentCoinUsdCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentCoinUsdCurrency: %w", err)
	}
	return oldValue.PaymentCoinUsdCurrency, nil
}

// ClearPaymentCoinUsdCurrency clears the value of the "payment_coin_usd_currency" field.
func (m *StatementMutation) ClearPaymentCoinUsdCurrency() {
	m.payment_coin_usd_currency = nil
	m.clearedFields[statement.FieldPaymentCoinUsdCurrency] = struct{}{}
}

// PaymentCoinUsdCurrencyCleared returns if the "payment_coin_usd_currency" field was cleared in this mutation.
func (m *StatementMutation) PaymentCoinUsdCurrencyCleared() bool {
	_, ok := m.clearedFields[statement.FieldPaymentCoinUsdCurrency]
	return ok
}

// ResetPaymentCoinUsdCurrency resets all changes to the "payment_coin_usd_currency" field.
func (m *StatementMutation) ResetPaymentCoinUsdCurrency() {
	m.payment_coin_usd_currency = nil
	delete(m.clearedFields, statement.FieldPaymentCoinUsdCurrency)
}

// SetUnits sets the "units" field.
func (m *StatementMutation) SetUnits(u uint32) {
	m.units = &u
	m.addunits = nil
}

// Units returns the value of the "units" field in the mutation.
func (m *StatementMutation) Units() (r uint32, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldUnits(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// AddUnits adds u to the "units" field.
func (m *StatementMutation) AddUnits(u int32) {
	if m.addunits != nil {
		*m.addunits += u
	} else {
		m.addunits = &u
	}
}

// AddedUnits returns the value that was added to the "units" field in this mutation.
func (m *StatementMutation) AddedUnits() (r int32, exists bool) {
	v := m.addunits
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnits clears the value of the "units" field.
func (m *StatementMutation) ClearUnits() {
	m.units = nil
	m.addunits = nil
	m.clearedFields[statement.FieldUnits] = struct{}{}
}

// UnitsCleared returns if the "units" field was cleared in this mutation.
func (m *StatementMutation) UnitsCleared() bool {
	_, ok := m.clearedFields[statement.FieldUnits]
	return ok
}

// ResetUnits resets all changes to the "units" field.
func (m *StatementMutation) ResetUnits() {
	m.units = nil
	m.addunits = nil
	delete(m.clearedFields, statement.FieldUnits)
}

// SetUnitsV1 sets the "units_v1" field.
func (m *StatementMutation) SetUnitsV1(d decimal.Decimal) {
	m.units_v1 = &d
}

// UnitsV1 returns the value of the "units_v1" field in the mutation.
func (m *StatementMutation) UnitsV1() (r decimal.Decimal, exists bool) {
	v := m.units_v1
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitsV1 returns the old "units_v1" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldUnitsV1(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitsV1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitsV1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitsV1: %w", err)
	}
	return oldValue.UnitsV1, nil
}

// ClearUnitsV1 clears the value of the "units_v1" field.
func (m *StatementMutation) ClearUnitsV1() {
	m.units_v1 = nil
	m.clearedFields[statement.FieldUnitsV1] = struct{}{}
}

// UnitsV1Cleared returns if the "units_v1" field was cleared in this mutation.
func (m *StatementMutation) UnitsV1Cleared() bool {
	_, ok := m.clearedFields[statement.FieldUnitsV1]
	return ok
}

// ResetUnitsV1 resets all changes to the "units_v1" field.
func (m *StatementMutation) ResetUnitsV1() {
	m.units_v1 = nil
	delete(m.clearedFields, statement.FieldUnitsV1)
}

// SetAmount sets the "amount" field.
func (m *StatementMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
}

// Amount returns the value of the "amount" field in the mutation.
func (m *StatementMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *StatementMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[statement.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *StatementMutation) AmountCleared() bool {
	_, ok := m.clearedFields[statement.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *StatementMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, statement.FieldAmount)
}

// SetUsdAmount sets the "usd_amount" field.
func (m *StatementMutation) SetUsdAmount(d decimal.Decimal) {
	m.usd_amount = &d
}

// UsdAmount returns the value of the "usd_amount" field in the mutation.
func (m *StatementMutation) UsdAmount() (r decimal.Decimal, exists bool) {
	v := m.usd_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldUsdAmount returns the old "usd_amount" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldUsdAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsdAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsdAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsdAmount: %w", err)
	}
	return oldValue.UsdAmount, nil
}

// ClearUsdAmount clears the value of the "usd_amount" field.
func (m *StatementMutation) ClearUsdAmount() {
	m.usd_amount = nil
	m.clearedFields[statement.FieldUsdAmount] = struct{}{}
}

// UsdAmountCleared returns if the "usd_amount" field was cleared in this mutation.
func (m *StatementMutation) UsdAmountCleared() bool {
	_, ok := m.clearedFields[statement.FieldUsdAmount]
	return ok
}

// ResetUsdAmount resets all changes to the "usd_amount" field.
func (m *StatementMutation) ResetUsdAmount() {
	m.usd_amount = nil
	delete(m.clearedFields, statement.FieldUsdAmount)
}

// SetCommission sets the "commission" field.
func (m *StatementMutation) SetCommission(d decimal.Decimal) {
	m.commission = &d
}

// Commission returns the value of the "commission" field in the mutation.
func (m *StatementMutation) Commission() (r decimal.Decimal, exists bool) {
	v := m.commission
	if v == nil {
		return
	}
	return *v, true
}

// OldCommission returns the old "commission" field's value of the Statement entity.
// If the Statement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementMutation) OldCommission(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommission: %w", err)
	}
	return oldValue.Commission, nil
}

// ClearCommission clears the value of the "commission" field.
func (m *StatementMutation) ClearCommission() {
	m.commission = nil
	m.clearedFields[statement.FieldCommission] = struct{}{}
}

// CommissionCleared returns if the "commission" field was cleared in this mutation.
func (m *StatementMutation) CommissionCleared() bool {
	_, ok := m.clearedFields[statement.FieldCommission]
	return ok
}

// ResetCommission resets all changes to the "commission" field.
func (m *StatementMutation) ResetCommission() {
	m.commission = nil
	delete(m.clearedFields, statement.FieldCommission)
}

// Where appends a list predicates to the StatementMutation builder.
func (m *StatementMutation) Where(ps ...predicate.Statement) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StatementMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Statement).
func (m *StatementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatementMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, statement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, statement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, statement.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, statement.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, statement.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, statement.FieldUserID)
	}
	if m.direct_contributor_id != nil {
		fields = append(fields, statement.FieldDirectContributorID)
	}
	if m.good_id != nil {
		fields = append(fields, statement.FieldGoodID)
	}
	if m.app_good_id != nil {
		fields = append(fields, statement.FieldAppGoodID)
	}
	if m.order_id != nil {
		fields = append(fields, statement.FieldOrderID)
	}
	if m.self_order != nil {
		fields = append(fields, statement.FieldSelfOrder)
	}
	if m.payment_id != nil {
		fields = append(fields, statement.FieldPaymentID)
	}
	if m.coin_type_id != nil {
		fields = append(fields, statement.FieldCoinTypeID)
	}
	if m.payment_coin_type_id != nil {
		fields = append(fields, statement.FieldPaymentCoinTypeID)
	}
	if m.payment_coin_usd_currency != nil {
		fields = append(fields, statement.FieldPaymentCoinUsdCurrency)
	}
	if m.units != nil {
		fields = append(fields, statement.FieldUnits)
	}
	if m.units_v1 != nil {
		fields = append(fields, statement.FieldUnitsV1)
	}
	if m.amount != nil {
		fields = append(fields, statement.FieldAmount)
	}
	if m.usd_amount != nil {
		fields = append(fields, statement.FieldUsdAmount)
	}
	if m.commission != nil {
		fields = append(fields, statement.FieldCommission)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statement.FieldCreatedAt:
		return m.CreatedAt()
	case statement.FieldUpdatedAt:
		return m.UpdatedAt()
	case statement.FieldDeletedAt:
		return m.DeletedAt()
	case statement.FieldEntID:
		return m.EntID()
	case statement.FieldAppID:
		return m.AppID()
	case statement.FieldUserID:
		return m.UserID()
	case statement.FieldDirectContributorID:
		return m.DirectContributorID()
	case statement.FieldGoodID:
		return m.GoodID()
	case statement.FieldAppGoodID:
		return m.AppGoodID()
	case statement.FieldOrderID:
		return m.OrderID()
	case statement.FieldSelfOrder:
		return m.SelfOrder()
	case statement.FieldPaymentID:
		return m.PaymentID()
	case statement.FieldCoinTypeID:
		return m.CoinTypeID()
	case statement.FieldPaymentCoinTypeID:
		return m.PaymentCoinTypeID()
	case statement.FieldPaymentCoinUsdCurrency:
		return m.PaymentCoinUsdCurrency()
	case statement.FieldUnits:
		return m.Units()
	case statement.FieldUnitsV1:
		return m.UnitsV1()
	case statement.FieldAmount:
		return m.Amount()
	case statement.FieldUsdAmount:
		return m.UsdAmount()
	case statement.FieldCommission:
		return m.Commission()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case statement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case statement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case statement.FieldEntID:
		return m.OldEntID(ctx)
	case statement.FieldAppID:
		return m.OldAppID(ctx)
	case statement.FieldUserID:
		return m.OldUserID(ctx)
	case statement.FieldDirectContributorID:
		return m.OldDirectContributorID(ctx)
	case statement.FieldGoodID:
		return m.OldGoodID(ctx)
	case statement.FieldAppGoodID:
		return m.OldAppGoodID(ctx)
	case statement.FieldOrderID:
		return m.OldOrderID(ctx)
	case statement.FieldSelfOrder:
		return m.OldSelfOrder(ctx)
	case statement.FieldPaymentID:
		return m.OldPaymentID(ctx)
	case statement.FieldCoinTypeID:
		return m.OldCoinTypeID(ctx)
	case statement.FieldPaymentCoinTypeID:
		return m.OldPaymentCoinTypeID(ctx)
	case statement.FieldPaymentCoinUsdCurrency:
		return m.OldPaymentCoinUsdCurrency(ctx)
	case statement.FieldUnits:
		return m.OldUnits(ctx)
	case statement.FieldUnitsV1:
		return m.OldUnitsV1(ctx)
	case statement.FieldAmount:
		return m.OldAmount(ctx)
	case statement.FieldUsdAmount:
		return m.OldUsdAmount(ctx)
	case statement.FieldCommission:
		return m.OldCommission(ctx)
	}
	return nil, fmt.Errorf("unknown Statement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statement.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case statement.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case statement.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case statement.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case statement.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case statement.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case statement.FieldDirectContributorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectContributorID(v)
		return nil
	case statement.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case statement.FieldAppGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppGoodID(v)
		return nil
	case statement.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case statement.FieldSelfOrder:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfOrder(v)
		return nil
	case statement.FieldPaymentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentID(v)
		return nil
	case statement.FieldCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinTypeID(v)
		return nil
	case statement.FieldPaymentCoinTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentCoinTypeID(v)
		return nil
	case statement.FieldPaymentCoinUsdCurrency:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentCoinUsdCurrency(v)
		return nil
	case statement.FieldUnits:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	case statement.FieldUnitsV1:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitsV1(v)
		return nil
	case statement.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case statement.FieldUsdAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsdAmount(v)
		return nil
	case statement.FieldCommission:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommission(v)
		return nil
	}
	return fmt.Errorf("unknown Statement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, statement.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, statement.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, statement.FieldDeletedAt)
	}
	if m.addunits != nil {
		fields = append(fields, statement.FieldUnits)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case statement.FieldCreatedAt:
		return m.AddedCreatedAt()
	case statement.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case statement.FieldDeletedAt:
		return m.AddedDeletedAt()
	case statement.FieldUnits:
		return m.AddedUnits()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case statement.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case statement.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case statement.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case statement.FieldUnits:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnits(v)
		return nil
	}
	return fmt.Errorf("unknown Statement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(statement.FieldAppID) {
		fields = append(fields, statement.FieldAppID)
	}
	if m.FieldCleared(statement.FieldUserID) {
		fields = append(fields, statement.FieldUserID)
	}
	if m.FieldCleared(statement.FieldDirectContributorID) {
		fields = append(fields, statement.FieldDirectContributorID)
	}
	if m.FieldCleared(statement.FieldGoodID) {
		fields = append(fields, statement.FieldGoodID)
	}
	if m.FieldCleared(statement.FieldAppGoodID) {
		fields = append(fields, statement.FieldAppGoodID)
	}
	if m.FieldCleared(statement.FieldOrderID) {
		fields = append(fields, statement.FieldOrderID)
	}
	if m.FieldCleared(statement.FieldSelfOrder) {
		fields = append(fields, statement.FieldSelfOrder)
	}
	if m.FieldCleared(statement.FieldPaymentID) {
		fields = append(fields, statement.FieldPaymentID)
	}
	if m.FieldCleared(statement.FieldCoinTypeID) {
		fields = append(fields, statement.FieldCoinTypeID)
	}
	if m.FieldCleared(statement.FieldPaymentCoinTypeID) {
		fields = append(fields, statement.FieldPaymentCoinTypeID)
	}
	if m.FieldCleared(statement.FieldPaymentCoinUsdCurrency) {
		fields = append(fields, statement.FieldPaymentCoinUsdCurrency)
	}
	if m.FieldCleared(statement.FieldUnits) {
		fields = append(fields, statement.FieldUnits)
	}
	if m.FieldCleared(statement.FieldUnitsV1) {
		fields = append(fields, statement.FieldUnitsV1)
	}
	if m.FieldCleared(statement.FieldAmount) {
		fields = append(fields, statement.FieldAmount)
	}
	if m.FieldCleared(statement.FieldUsdAmount) {
		fields = append(fields, statement.FieldUsdAmount)
	}
	if m.FieldCleared(statement.FieldCommission) {
		fields = append(fields, statement.FieldCommission)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatementMutation) ClearField(name string) error {
	switch name {
	case statement.FieldAppID:
		m.ClearAppID()
		return nil
	case statement.FieldUserID:
		m.ClearUserID()
		return nil
	case statement.FieldDirectContributorID:
		m.ClearDirectContributorID()
		return nil
	case statement.FieldGoodID:
		m.ClearGoodID()
		return nil
	case statement.FieldAppGoodID:
		m.ClearAppGoodID()
		return nil
	case statement.FieldOrderID:
		m.ClearOrderID()
		return nil
	case statement.FieldSelfOrder:
		m.ClearSelfOrder()
		return nil
	case statement.FieldPaymentID:
		m.ClearPaymentID()
		return nil
	case statement.FieldCoinTypeID:
		m.ClearCoinTypeID()
		return nil
	case statement.FieldPaymentCoinTypeID:
		m.ClearPaymentCoinTypeID()
		return nil
	case statement.FieldPaymentCoinUsdCurrency:
		m.ClearPaymentCoinUsdCurrency()
		return nil
	case statement.FieldUnits:
		m.ClearUnits()
		return nil
	case statement.FieldUnitsV1:
		m.ClearUnitsV1()
		return nil
	case statement.FieldAmount:
		m.ClearAmount()
		return nil
	case statement.FieldUsdAmount:
		m.ClearUsdAmount()
		return nil
	case statement.FieldCommission:
		m.ClearCommission()
		return nil
	}
	return fmt.Errorf("unknown Statement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatementMutation) ResetField(name string) error {
	switch name {
	case statement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case statement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case statement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case statement.FieldEntID:
		m.ResetEntID()
		return nil
	case statement.FieldAppID:
		m.ResetAppID()
		return nil
	case statement.FieldUserID:
		m.ResetUserID()
		return nil
	case statement.FieldDirectContributorID:
		m.ResetDirectContributorID()
		return nil
	case statement.FieldGoodID:
		m.ResetGoodID()
		return nil
	case statement.FieldAppGoodID:
		m.ResetAppGoodID()
		return nil
	case statement.FieldOrderID:
		m.ResetOrderID()
		return nil
	case statement.FieldSelfOrder:
		m.ResetSelfOrder()
		return nil
	case statement.FieldPaymentID:
		m.ResetPaymentID()
		return nil
	case statement.FieldCoinTypeID:
		m.ResetCoinTypeID()
		return nil
	case statement.FieldPaymentCoinTypeID:
		m.ResetPaymentCoinTypeID()
		return nil
	case statement.FieldPaymentCoinUsdCurrency:
		m.ResetPaymentCoinUsdCurrency()
		return nil
	case statement.FieldUnits:
		m.ResetUnits()
		return nil
	case statement.FieldUnitsV1:
		m.ResetUnitsV1()
		return nil
	case statement.FieldAmount:
		m.ResetAmount()
		return nil
	case statement.FieldUsdAmount:
		m.ResetUsdAmount()
		return nil
	case statement.FieldCommission:
		m.ResetCommission()
		return nil
	}
	return fmt.Errorf("unknown Statement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Statement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Statement edge %s", name)
}
